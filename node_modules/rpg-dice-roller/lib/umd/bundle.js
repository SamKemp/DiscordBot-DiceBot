/**
 * rpg-dice-roller - An advanced JS based dice roller that can roll various types of dice and modifiers, along with mathematical equations.
 * 
 * @version 5.0.0
 * @license MIT
 * @author GreenImp <info@greenimp.co.uk> (http://greenimp.co.uk)
 * @link https://greenimp.github.io/rpg-dice-roller/
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('mathjs'), require('random-js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'mathjs', 'random-js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rpgDiceRoller = {}, global.math, global.Random));
}(this, (function (exports, mathjs, randomJs) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /**
   * An error thrown when a comparison operator is invalid
   */
  var CompareOperatorError = /*#__PURE__*/function (_TypeError) {
    _inherits(CompareOperatorError, _TypeError);

    var _super = _createSuper(CompareOperatorError);

    /**
     * Create a `CompareOperatorError`
     *
     * @param {*} operator The invalid operator
     */
    function CompareOperatorError(operator) {
      var _this;

      _classCallCheck(this, CompareOperatorError);

      _this = _super.call(this, "Operator \"".concat(operator, "\" is invalid")); // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (TypeError.captureStackTrace) {
        TypeError.captureStackTrace(_assertThisInitialized(_this), CompareOperatorError);
      }

      _this.name = 'CompareOperatorError';
      _this.operator = operator;
      return _this;
    }

    return CompareOperatorError;
  }( /*#__PURE__*/_wrapNativeSuper(TypeError));

  /**
   * An error thrown when a data format is invalid
   */
  var DataFormatError = /*#__PURE__*/function (_Error) {
    _inherits(DataFormatError, _Error);

    var _super = _createSuper(DataFormatError);

    /**
     * Create a `DataFormatError`
     *
     * @param {*} data The invalid data
     */
    function DataFormatError(data) {
      var _this;

      _classCallCheck(this, DataFormatError);

      _this = _super.call(this, "Invalid data format: ".concat(data)); // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), DataFormatError);
      }

      _this.name = 'ImportError';
      _this.data = data;
      return _this;
    }

    return DataFormatError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  /**
   * An error thrown when an invalid die action (e.g Exploding on a d1) occurs
   */
  var DieActionValueError = /*#__PURE__*/function (_Error) {
    _inherits(DieActionValueError, _Error);

    var _super = _createSuper(DieActionValueError);

    /**
     * Create a `DieActionValueError`
     *
     * @param {StandardDice} die The die the action was on
     * @param {string|null} [action=null] The invalid action
     */
    function DieActionValueError(die) {
      var _this;

      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, DieActionValueError);

      _this = _super.call(this, "Die \"".concat(die, "\" must have more than 1 possible value to ").concat(action || 'do this action')); // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), DieActionValueError);
      }

      _this.name = 'DieActionValueError';
      _this.action = action;
      _this.die = die;
      return _this;
    }

    return DieActionValueError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  /**
   * An error thrown when the notation is invalid
   */
  var NotationError = /*#__PURE__*/function (_Error) {
    _inherits(NotationError, _Error);

    var _super = _createSuper(NotationError);

    /**
     * Create a `NotationError`
     *
     * @param {*} notation The invalid notation
     */
    function NotationError(notation) {
      var _this;

      _classCallCheck(this, NotationError);

      _this = _super.call(this, "Notation \"".concat(notation, "\" is invalid")); // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), NotationError);
      }

      _this.name = 'NotationError';
      _this.notation = notation;
      return _this;
    }

    return NotationError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  /**
   * An error thrown when a required argument is missing
   */
  var RequiredArgumentError = /*#__PURE__*/function (_Error) {
    _inherits(RequiredArgumentError, _Error);

    var _super = _createSuper(RequiredArgumentError);

    /**
     * Create a `RequiredArgumentError`
     *
     * @param {string|null} [argumentName=null] The argument name
     */
    function RequiredArgumentError() {
      var _this;

      var argumentName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _classCallCheck(this, RequiredArgumentError);

      _this = _super.call(this, "Missing argument".concat(argumentName ? " \"".concat(argumentName, "\"") : '')); // Maintains proper stack trace for where our error was thrown (only available on V8)

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), RequiredArgumentError);
      }

      _this.argumentName = argumentName;
      return _this;
    }

    return RequiredArgumentError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CompareOperatorError: CompareOperatorError,
    DataFormatError: DataFormatError,
    DieActionValueError: DieActionValueError,
    NotationError: NotationError,
    RequiredArgumentError: RequiredArgumentError
  });

  /**
   * Check if `a` is comparative to `b` with the given operator.
   *
   * @example <caption>Is `a` greater than `b`?</caption>
   * const a = 4;
   * const b = 2;
   *
   * compareNumber(a, b, '>'); // true
   *
   * @example <caption>Is `a` equal to `b`?</caption>
   * const a = 4;
   * const b = 2;
   *
   * compareNumber(a, b, '='); // false
   *
   * @param {number} a The number to compare with `b`
   * @param {number} b The number to compare with `a`
   * @param {string} operator A valid comparative operator: `=, <, >, <=, >=, !=`
   *
   * @returns {boolean} `true` if the comparison matches, `false` otherwise
   */

  var compareNumbers = function compareNumbers(a, b, operator) {
    var aNum = Number(a);
    var bNum = Number(b);
    var result;

    if (Number.isNaN(aNum) || Number.isNaN(bNum)) {
      return false;
    }

    switch (operator) {
      case '=':
      case '==':
        result = aNum === bNum;
        break;

      case '<':
        result = aNum < bNum;
        break;

      case '>':
        result = aNum > bNum;
        break;

      case '<=':
        result = aNum <= bNum;
        break;

      case '>=':
        result = aNum >= bNum;
        break;

      case '!':
      case '!=':
        result = aNum !== bNum;
        break;

      default:
        result = false;
        break;
    }

    return result;
  };
  /**
   * Evaluate mathematical strings.
   *
   * @example
   * evaluate('5+6'); // 11
   *
   * @param {string} equation The mathematical equation to compute.
   *
   * @returns {number} The result of the equation
   */


  var evaluate = function evaluate(equation) {
    return mathjs.evaluate(equation);
  };
  /**
   * Check if the given value is a valid finite number.
   *
   * @param {*} val
   *
   * @returns {boolean} `true` if it is a finite number, `false` otherwise
   */


  var isNumeric = function isNumeric(val) {
    if (typeof val !== 'number' && typeof val !== 'string') {
      return false;
    }

    return !Number.isNaN(val) && Number.isFinite(Number(val));
  };
  /**
   * Check if the given value is a "safe" number.
   *
   * A "safe" number falls within the `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER` values
   * (Inclusive).
   *
   * @param {*} val
   *
   * @returns {boolean} `true` if the value is a "safe" number, `false` otherwise
   */


  var isSafeNumber = function isSafeNumber(val) {
    if (!isNumeric(val)) {
      return false;
    }

    var castVal = Number(val);
    return castVal <= Number.MAX_SAFE_INTEGER && castVal >= Number.MIN_SAFE_INTEGER;
  };
  /**
   * Take an array of numbers and add the values together.
   *
   * @param {number[]} numbers
   *
   * @returns {number} The summed value
   */


  var sumArray = function sumArray(numbers) {
    return !Array.isArray(numbers) ? 0 : numbers.reduce(function (prev, current) {
      return prev + (isNumeric(current) ? parseFloat("".concat(current)) : 0);
    }, 0);
  };
  /**
   * Round a number to the given amount of digits after the decimal point, removing any trailing
   * zeros after the decimal point.
   *
   * @example
   * toFixed(1.236, 2); // 1.24
   * toFixed(30.1, 2); // 30.1
   * toFixed(4.0000000004, 3); // 4
   *
   * @param {number} num The number to round
   * @param {number} [precision=0] The number of digits after the decimal point
   *
   * @returns {number}
   */


  var toFixed = function toFixed(num) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return (// round to precision, then cast to a number to remove trailing zeroes after the decimal point
      parseFloat(parseFloat("".concat(num)).toFixed(precision || 0))
    );
  };

  /**
   * The engine
   *
   * @type {symbol}
   *
   * @private
   */

  var engineSymbol = Symbol('engine');
  /**
   * The random object
   *
   * @type {symbol}
   *
   * @private
   */

  var randomSymbol = Symbol('random');
  /**
   * Engine that always returns the maximum value.
   * Used internally for calculating max roll values.
   *
   * @since 4.2.0
   *
   * @type {{next(): number, range: number[]}}
   */

  var maxEngine = {
    /**
     * The min / max number range (e.g. `[1, 10]`).
     *
     * This _must_ be set for the `next()` method to return the correct last index.
     *
     * @example
     * maxEngine.range = [1, 10];
     *
     * @type {number[]}
     */
    range: [],

    /**
     * Returns the maximum number index for the range
     *
     * @returns {number}
     */
    next: function next() {
      // calculate the index of the max number
      return this.range[1] - this.range[0];
    }
  };
  /**
   * Engine that always returns the minimum value.
   * Used internally for calculating min roll values.
   *
   * @since 4.2.0
   *
   * @type {{next(): number}}
   */

  var minEngine = {
    /**
     * Returns the minimum number index, `0`
     *
     * @returns {number}
     */
    next: function next() {
      return 0;
    }
  };
  /**
   * List of built-in number generator engines.
   *
   * @since 4.2.0
   *
   * @see This uses [random-js](https://github.com/ckknight/random-js).
   * For details of the engines, check the [documentation](https://github.com/ckknight/random-js#engines).
   *
   * @type {{
   *  min: {next(): number},
   *  max: {next(): number, range: number[]},
   *  browserCrypto: Engine,
   *  nodeCrypto: Engine,
   *  MersenneTwister19937: MersenneTwister19937,
   *  nativeMath: Engine
   * }}
   */

  var engines = {
    browserCrypto: randomJs.browserCrypto,
    nodeCrypto: randomJs.nodeCrypto,
    MersenneTwister19937: randomJs.MersenneTwister19937,
    nativeMath: randomJs.nativeMath,
    min: minEngine,
    max: maxEngine
  };
  /**
   * The `NumberGenerator` is capable of generating random numbers.
   *
   * @since 4.2.0
   *
   * @see This uses [random-js](https://github.com/ckknight/random-js).
   * For details of the engines, check the [documentation](https://github.com/ckknight/random-js#engines).
   */

  var NumberGenerator = /*#__PURE__*/function () {
    /**
     * Create a `NumberGenerator` instance.
     *
     * The `engine` can be any object that has a `next()` method, which returns a number.
     *
     * @example <caption>Built-in engine</caption>
     * new NumberGenerator(engines.nodeCrypto);
     *
     * @example <caption>Custom engine</caption>
     * new NumberGenerator({
     *   next() {
     *     // return a random number
     *   },
     * });
     *
     * @param {Engine|{next(): number}} [engine=nativeMath] The RNG engine to use
     *
     * @throws {TypeError} engine must have function `next()`
     */
    function NumberGenerator() {
      var engine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : randomJs.nativeMath;

      _classCallCheck(this, NumberGenerator);

      this.engine = engine || randomJs.nativeMath;
    }
    /**
     * The current engine.
     *
     * @returns {Engine|{next(): number}}
     */


    _createClass(NumberGenerator, [{
      key: "engine",
      get: function get() {
        return this[engineSymbol];
      }
      /**
       * Set the engine.
       *
       * The `engine` can be any object that has a `next()` method, which returns a number.
       *
       * @example <caption>Built-in engine</caption>
       * numberGenerator.engine = engines.nodeCrypto;
       *
       * @example <caption>Custom engine</caption>
       * numberGenerator.engine = {
       *   next() {
       *     // return a random number
       *   },
       * });
       *
       * @see {@link engines}
       *
       * @param {Engine|{next(): number}} engine
       *
       * @throws {TypeError} engine must have function `next()`
       */
      ,
      set: function set(engine) {
        if (engine && typeof engine.next !== 'function') {
          throw new TypeError('engine must have function `next()`');
        } // set the engine and re-initialise the random engine


        this[engineSymbol] = engine || randomJs.nativeMath;
        this[randomSymbol] = new randomJs.Random(this[engineSymbol]);
      }
      /**
       * Generate a random integer within the inclusive range `[min, max]`.
       *
       * @param {number} min The minimum integer value, inclusive.
       * @param {number} max The maximum integer value, inclusive.
       *
       * @returns {number} The random integer
       */

    }, {
      key: "integer",
      value: function integer(min, max) {
        this[engineSymbol].range = [min, max];
        return this[randomSymbol].integer(min, max);
      }
      /**
       * Returns a floating-point value within `[min, max)` or `[min, max]`.
       *
       * @param {number} min The minimum floating-point value, inclusive.
       * @param {number} max The maximum floating-point value.
       * @param {boolean} [inclusive=false] If `true`, `max` will be inclusive.
       *
       * @returns {number} The random floating-point value
       */

    }, {
      key: "real",
      value: function real(min, max) {
        var inclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        this[engineSymbol].range = [min, max];
        return this[randomSymbol].real(min, max, inclusive);
      }
    }]);

    return NumberGenerator;
  }();

  var generator = new NumberGenerator();

  var NumberGenerator$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    engines: engines,
    generator: generator
  });

  /**
   * The operator
   *
   * @type {symbol}
   *
   * @private
   */

  var operatorSymbol = Symbol('operator');
  /**
   * The value
   *
   * @type {symbol}
   *
   * @private
   */

  var valueSymbol$1 = Symbol('value');
  /**
   * A `ComparePoint` object compares numbers against each other.
   * For example, _is 6 greater than 3_, or _is 8 equal to 10_.
   */

  var ComparePoint = /*#__PURE__*/function () {
    /**
     * Create a `ComparePoint` instance.
     *
     * @param {string} operator The comparison operator (One of `=`, `!=`, `<`, `>`, `<=`, `>=`)
     * @param {number} value The value to compare to
     *
     * @throws {CompareOperatorError} operator is invalid
     * @throws {RequiredArgumentError} operator and value are required
     * @throws {TypeError} value must be numeric
     */
    function ComparePoint(operator, value) {
      _classCallCheck(this, ComparePoint);

      if (!operator) {
        throw new RequiredArgumentError('operator');
      } else if (!value && value !== 0) {
        throw new RequiredArgumentError('value');
      }

      this.operator = operator;
      this.value = value;
    }
    /**
     * Check if the operator is valid.
     *
     * @param {string} operator
     *
     * @returns {boolean} `true` if the operator is valid, `false` otherwise
     */


    _createClass(ComparePoint, [{
      key: "operator",
      get:
      /**
       * The comparison operator.
       *
       * @returns {string}
       */
      function get() {
        return this[operatorSymbol];
      }
      /**
       * Set the value.
       *
       * @param {number} value
       *
       * @throws {TypeError} value must be numeric
       */
      ,
      set:
      /**
       * Set the comparison operator.
       *
       * @param {string} operator One of `=`, `!=`, `<`, `>`, `<=`, `>=`
       *
       * @throws CompareOperatorError operator is invalid
       */
      function set(operator) {
        if (!this.constructor.isValidOperator(operator)) {
          throw new CompareOperatorError(operator);
        }

        this[operatorSymbol] = operator;
      }
    }, {
      key: "value",
      get:
      /**
       * The comparison value
       *
       * @returns {number}
       */
      function get() {
        return this[valueSymbol$1];
      }
      /**
       * Check whether value matches the compare point
       *
       * @param {number} value The number to compare
       *
       * @returns {boolean} `true` if it is a match, `false` otherwise
       */
      ,
      set: function set(value) {
        if (!isNumeric(value)) {
          throw new TypeError('value must be a finite number');
        }

        this[valueSymbol$1] = Number(value);
      }
    }, {
      key: "isMatch",
      value: function isMatch(value) {
        return compareNumbers(value, this.value, this.operator);
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{type: string, value: number, operator: string}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var operator = this.operator,
            value = this.value;
        return {
          operator: operator,
          type: 'compare-point',
          value: value
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.operator).concat(this.value);
      }
    }], [{
      key: "isValidOperator",
      value: function isValidOperator(operator) {
        return typeof operator === 'string' && /^(?:[<>!]?=|[<>])$/.test(operator);
      }
    }]);

    return ComparePoint;
  }();

  /**
   * A `Modifier` is the base modifier class that all others extend from.
   *
   * ::: warning Abstract class
   * This is meant as an abstract class and should not be used directly.
   * :::
   *
   * @abstract
   */
  var Modifier = /*#__PURE__*/function () {
    /**
     * Create a `Modifier` instance.
     */
    function Modifier() {
      _classCallCheck(this, Modifier);

      // set the modifier's sort order
      this.order = 999;
    }
    /* eslint-disable class-methods-use-this */

    /**
     * The name of the modifier.
     *
     * @returns {string} 'modifier'
     */


    _createClass(Modifier, [{
      key: "name",
      get: function get() {
        return 'modifier';
      }
      /* eslint-enable class-methods-use-this */

      /* eslint-disable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return '';
      }
      /* eslint-enable class-methods-use-this */

      /* eslint-disable class-methods-use-this */

      /**
       * The maximum number of iterations that the modifier can apply to a single die roll
       *
       * @returns {number} `1000`
       */

    }, {
      key: "maxIterations",
      get: function get() {
        return 1000;
      }
      /* eslint-enable class-methods-use-this */

      /* eslint-disable class-methods-use-this */

      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        return results;
      }
      /* eslint-enable class-methods-use-this */

      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{notation: string, name: string, type: string}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var notation = this.notation,
            name = this.name;
        return {
          name: name,
          notation: notation,
          type: 'modifier'
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @see {@link Modifier#notation}
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.notation;
      }
    }]);

    return Modifier;
  }();

  var comparePointSymbol = Symbol('compare-point');
  /**
   * A `ComparisonModifier` is the base modifier class for comparing values.
   *
   * ::: warning Abstract class
   * This is meant as an abstract class and should not be used directly.
   * You can use one of the extended modifiers, or extend the class yourself.
   * :::
   *
   * @abstract
   *
   * @extends Modifier
   *
   * @see {@link CriticalFailureModifier}
   * @see {@link CriticalSuccessModifier}
   * @see {@link ExplodeModifier}
   * @see {@link ReRollModifier}
   * @see {@link TargetModifier}
   */

  var ComparisonModifier = /*#__PURE__*/function (_Modifier) {
    _inherits(ComparisonModifier, _Modifier);

    var _super = _createSuper(ComparisonModifier);

    /**
     * Create a `ComparisonModifier` instance.
     *
     * @param {ComparePoint} [comparePoint] The comparison object
     *
     * @throws {TypeError} `comparePoint` must be an instance of `ComparePoint` or `undefined`
     */
    function ComparisonModifier(comparePoint) {
      var _this;

      _classCallCheck(this, ComparisonModifier);

      _this = _super.call(this);

      if (comparePoint) {
        _this.comparePoint = comparePoint;
      }

      return _this;
    }
    /**
     * The compare point.
     *
     * @returns {ComparePoint|undefined}
     */


    _createClass(ComparisonModifier, [{
      key: "comparePoint",
      get: function get() {
        return this[comparePointSymbol];
      }
      /**
       * Set the compare point.
       *
       * @param {ComparePoint} comparePoint
       *
       * @throws {TypeError} value must be an instance of `ComparePoint`
       */
      ,
      set: function set(comparePoint) {
        if (!(comparePoint instanceof ComparePoint)) {
          throw new TypeError('comparePoint must be instance of ComparePoint');
        }

        this[comparePointSymbol] = comparePoint;
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the modifier.
       *
       * @returns {string} 'comparison'
       */

    }, {
      key: "name",
      get: function get() {
        return 'comparison';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "".concat(this.comparePoint || '');
      }
      /**
       * Check whether value matches the compare point or not.
       *
       * @param {number} value The value to compare with
       *
       * @returns {boolean} `true` if the value matches, `false` otherwise
       */

    }, {
      key: "isComparePoint",
      value: function isComparePoint(value) {
        if (!this.comparePoint) {
          return false;
        }

        return this.comparePoint.isMatch(value);
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  notation: string,
       *  name: string,
       *  type: string,
       *  comparePoint: (ComparePoint|undefined)
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var comparePoint = this.comparePoint;
        return Object.assign(_get(_getPrototypeOf(ComparisonModifier.prototype), "toJSON", this).call(this), {
          comparePoint: comparePoint
        });
      }
    }]);

    return ComparisonModifier;
  }(Modifier);

  var compoundSymbol = Symbol('compound');
  var penetrateSymbol = Symbol('penetrate');
  /**
   * An `ExplodeModifier` re-rolls dice that match a given test, and adds them to the results.
   *
   * @see {@link ReRollModifier} if you want to replace the old value with the new, rather than adding
   *
   * @extends ComparisonModifier
   */

  var ExplodeModifier = /*#__PURE__*/function (_ComparisonModifier) {
    _inherits(ExplodeModifier, _ComparisonModifier);

    var _super = _createSuper(ExplodeModifier);

    /**
     * Create an `ExplodeModifier` instance
     *
     * @param {ComparePoint} [comparePoint=null] The comparison object
     * @param {boolean} [compound=false] Whether to compound or not
     * @param {boolean} [penetrate=false] Whether to penetrate or not
     *
     * @throws {TypeError} comparePoint must be a `ComparePoint` object
     */
    function ExplodeModifier() {
      var _this;

      var comparePoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var compound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var penetrate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _classCallCheck(this, ExplodeModifier);

      _this = _super.call(this, comparePoint);
      _this[compoundSymbol] = !!compound;
      _this[penetrateSymbol] = !!penetrate; // set the modifier's sort order

      _this.order = 3;
      return _this;
    }
    /**
     * Whether the modifier should compound the results or not.
     *
     * @returns {boolean} `true` if it should compound, `false` otherwise
     */


    _createClass(ExplodeModifier, [{
      key: "compound",
      get: function get() {
        return this[compoundSymbol];
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the modifier.
       *
       * @returns {string} 'explode'
       */

    }, {
      key: "name",
      get: function get() {
        return 'explode';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "!".concat(this.compound ? '!' : '').concat(this.penetrate ? 'p' : '').concat(_get(_getPrototypeOf(ExplodeModifier.prototype), "notation", this));
      }
      /**
       * Whether the modifier should penetrate the results or not.
       *
       * @returns {boolean} `true` if it should penetrate, `false` otherwise
       */

    }, {
      key: "penetrate",
      get: function get() {
        return this[penetrateSymbol];
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        // ensure that the dice can explode without going into an infinite loop
        if (_context.min === _context.max) {
          throw new DieActionValueError(_context, 'explode');
        }

        var parsedResults = results;
        parsedResults.rolls = results.rolls.map(function (roll) {
          var subRolls = [roll];
          var compareValue = roll.value; // explode if the value matches the compare point, and we haven't reached the max iterations

          for (var i = 0; i < _this2.maxIterations && _this2.isComparePoint(compareValue); i++) {
            var prevRoll = subRolls[subRolls.length - 1]; // roll the dice

            var rollResult = _context.rollOnce(); // update the value to check against


            compareValue = rollResult.value; // add the explode modifier flag

            prevRoll.modifiers.add('explode'); // add the penetrate modifier flag and decrement the value

            if (_this2.penetrate) {
              prevRoll.modifiers.add('penetrate');
              rollResult.value -= 1;
            } // add the rolls to the list


            subRolls.push(rollResult);
          } // return the rolls (Compounded if necessary)

          /* eslint-disable  no-param-reassign */


          if (_this2.compound && subRolls.length > 1) {
            // update the roll value and modifiers
            roll.value = sumArray(subRolls.map(function (result) {
              return result.value;
            }));
            roll.modifiers = ['explode', 'compound'];

            if (_this2.penetrate) {
              roll.modifiers.add('penetrate');
            }

            return roll;
          }
          /* eslint-enable */


          return subRolls;
        }).flat();
        return parsedResults;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  notation: string,
       *  name: string,
       *  type: string,
       *  comparePoint: (ComparePoint|undefined),
       *  compound: boolean,
       *  penetrate: boolean
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var compound = this.compound,
            penetrate = this.penetrate;
        return Object.assign(_get(_getPrototypeOf(ExplodeModifier.prototype), "toJSON", this).call(this), {
          compound: compound,
          penetrate: penetrate
        });
      }
    }]);

    return ExplodeModifier;
  }(ComparisonModifier);

  var flags = {
    compound: '!',
    explode: '!',
    'critical-failure': '__',
    'critical-success': '**',
    drop: 'd',
    max: 'v',
    min: '^',
    penetrate: 'p',
    're-roll': 'r',
    're-roll-once': 'ro',
    'target-failure': '_',
    'target-success': '*'
  };
  /**
   * Return the flags for the given list of modifiers
   *
   * @param {...Modifier|string} modifiers
   *
   * @returns {string}
   */

  var getModifierFlags = function getModifierFlags() {
    for (var _len = arguments.length, modifiers = new Array(_len), _key = 0; _key < _len; _key++) {
      modifiers[_key] = arguments[_key];
    }

    return (// @todo need a better way of mapping modifiers to symbols
      [].concat(modifiers).reduce(function (acc, modifier) {
        var name;

        if (modifier instanceof Modifier) {
          name = modifier.name;
        } else {
          name = modifier;
        }

        return acc + (flags[name] || name);
      }, '')
    );
  };

  var calculationValueSymbol$1 = Symbol('calculation-value');
  var modifiersSymbol$3 = Symbol('modifiers');
  var initialValueSymbol = Symbol('initial-value');
  var useInTotalSymbol$1 = Symbol('use-in-total');
  var valueSymbol = Symbol('value');
  /**
   * A `RollResult` represents the value and applicable modifiers for a single die roll
   *
   * ::: tip
   * You will probably not need to create your own `RollResult` instances, unless you're importing
   * rolls, but `RollResult` objects will be returned when rolling dice.
   * :::
   */

  var RollResult = /*#__PURE__*/function () {
    /**
     * Create a `RollResult` instance.
     *
     * `value` can be a number, or an object containing a list of different values.
     * This allows you to specify the `initialValue`, `value` and `calculationValue` with different
     * values.
     *
     * @example <caption>Numerical value</caption>
     * const result = new RollResult(4);
     *
     * @example <caption>Object value</caption>
     * // must provide either `value` or `initialValue`
     * // `calculationValue` is optional.
     * const result = new RollResult({
     *   value: 6,
     *   initialValue: 4,
     *   calculationValue: 8,
     * });
     *
     * @example <caption>With modifiers</caption>
     * const result = new RollResult(4, ['explode', 'critical-success']);
     *
     * @param {number|{value: number, initialValue: number, calculationValue: number}} value The value
     * rolled
     * @param {number} [value.value] The value with modifiers applied
     * @param {number} [value.initialValue] The initial, unmodified value rolled
     * @param {number} [value.calculationValue] The value used in calculations
     * @param {string[]|Set<string>} [modifiers=[]] List of modifier names that affect this roll
     * @param {boolean} [useInTotal=true] Whether to include the roll value when calculating totals
     *
     * @throws {TypeError} Result value, calculation value, or modifiers are invalid
     */
    function RollResult(value) {
      var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var useInTotal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      _classCallCheck(this, RollResult);

      if (isNumeric(value)) {
        this[initialValueSymbol] = Number(value);
        this.modifiers = modifiers || [];
        this.useInTotal = useInTotal;
      } else if (value && _typeof(value) === 'object' && !Array.isArray(value)) {
        // ensure that we have a valid value
        var initialVal = isNumeric(value.initialValue) ? value.initialValue : value.value;

        if (!isNumeric(initialVal)) {
          throw new TypeError("Result value is invalid: ".concat(initialVal));
        }

        this[initialValueSymbol] = Number(initialVal);

        if (isNumeric(value.value) && Number(value.value) !== this[initialValueSymbol]) {
          this.value = value.value;
        }

        if (isNumeric(value.calculationValue) && parseFloat("".concat(value.calculationValue)) !== this.value) {
          this.calculationValue = value.calculationValue;
        }

        this.modifiers = value.modifiers || modifiers || [];
        this.useInTotal = typeof value.useInTotal === 'boolean' ? value.useInTotal : useInTotal || false;
      } else if (value === Infinity) {
        throw new RangeError('Result value must be a finite number');
      } else {
        throw new TypeError("Result value is invalid: ".concat(value));
      }
    }
    /**
     * The value to use in calculations.
     * This may be changed by modifiers.
     *
     * @returns {number}
     */


    _createClass(RollResult, [{
      key: "calculationValue",
      get: function get() {
        return isNumeric(this[calculationValueSymbol$1]) ? parseFloat(this[calculationValueSymbol$1]) : this.value;
      }
      /**
       * Set the value to use in calculations.
       *
       * @param {number} value
       *
       * @throws {TypeError} value is invalid
       */
      ,
      set: function set(value) {
        var isValNumeric = isNumeric(value);

        if (value === Infinity) {
          throw new RangeError('Result calculation value must be a finite number');
        }

        if (value && !isValNumeric) {
          throw new TypeError("Result calculation value is invalid: ".concat(value));
        }

        this[calculationValueSymbol$1] = isValNumeric ? parseFloat("".concat(value)) : null;
      }
      /**
       * The initial roll value before any modifiers.
       *
       * Not used for calculations and is just for reference.
       * You probably want `value` instead.
       *
       * @see {@link RollResult#value}
       *
       * @returns {number}
       */

    }, {
      key: "initialValue",
      get: function get() {
        return this[initialValueSymbol];
      }
      /**
       * The visual flags for the modifiers that affect the roll.
       *
       * @see {@link RollResult#modifiers}
       *
       * @returns {string}
       */

    }, {
      key: "modifierFlags",
      get: function get() {
        return getModifierFlags.apply(void 0, _toConsumableArray(this.modifiers));
      }
      /**
       * The names of modifiers that affect the roll.
       *
       * @returns {Set<string>}
       */

    }, {
      key: "modifiers",
      get: function get() {
        return this[modifiersSymbol$3];
      }
      /**
       * Set the modifier names that affect the roll.
       *
       * @example
       * rollResult.modifiers = ['explode', 're-roll'];
       *
       * @param {string[]|Set<string>} value
       *
       * @throws {TypeError} modifiers must be a Set or array of modifier names
       */
      ,
      set: function set(value) {
        if ((Array.isArray(value) || value instanceof Set) && _toConsumableArray(value).every(function (item) {
          return typeof item === 'string';
        })) {
          this[modifiersSymbol$3] = new Set(_toConsumableArray(value));
          return;
        }

        if (!value && value !== 0) {
          // clear the modifiers
          this[modifiersSymbol$3] = new Set();
          return;
        }

        throw new TypeError("modifiers must be a Set or array of modifier names: ".concat(value));
      }
      /**
       * Whether to use the value in total calculations or not.
       *
       * @returns {boolean}
       */

    }, {
      key: "useInTotal",
      get: function get() {
        return !!this[useInTotalSymbol$1];
      }
      /**
       * Set whether to use the value in total calculations or not.
       *
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this[useInTotalSymbol$1] = !!value;
      }
      /**
       * Value of the roll after modifiers have been applied.
       *
       * @returns {number}
       */

    }, {
      key: "value",
      get: function get() {
        return isNumeric(this[valueSymbol]) ? this[valueSymbol] : this[initialValueSymbol];
      }
      /**
       * Set the roll value.
       *
       * @param {number} value
       *
       * @throws {RangeError} value must be finite
       * @throws {TypeError} value is invalid
       */
      ,
      set: function set(value) {
        if (value === Infinity) {
          throw new RangeError('Result value must be a finite number');
        }

        if (!isNumeric(value)) {
          throw new TypeError("Result value is invalid: ".concat(value));
        }

        this[valueSymbol] = Number(value);
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  calculationValue: number,
       *  modifierFlags: string,
       *  modifiers: string[],
       *  type: string,
       *  initialValue: number,
       *  useInTotal: boolean,
       *  value: number
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var calculationValue = this.calculationValue,
            initialValue = this.initialValue,
            modifierFlags = this.modifierFlags,
            modifiers = this.modifiers,
            useInTotal = this.useInTotal,
            value = this.value;
        return {
          calculationValue: calculationValue,
          initialValue: initialValue,
          modifierFlags: modifierFlags,
          modifiers: _toConsumableArray(modifiers),
          type: 'result',
          useInTotal: useInTotal,
          value: value
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.value + this.modifierFlags;
      }
    }]);

    return RollResult;
  }();

  var rollsSymbol$1 = Symbol('rolls');
  /**
   * A collection of die roll results
   *
   * ::: tip
   * You will probably not need to create your own `RollResults` instances, unless you're importing
   * rolls, but RollResults objects will be returned when rolling dice.
   * :::
   */

  var RollResults = /*#__PURE__*/function () {
    /**
     * Create a `RollResults` instance.
     *
     * @example <caption>`RollResult` objects</caption>
     * const results = new RollResults([
     *  new RollResult(4),
     *  new RollResult(3),
     *  new RollResult(5),
     * ]);
     *
     * @example <caption>Numerical results</caption>
     * const results = new RollResults([4, 3, 5]);
     *
     * @example <caption>A mix</caption>
     * const results = new RollResults([
     *  new RollResult(4),
     *  3,
     *  new RollResult(5),
     * ]);
     *
     * @param {Array.<RollResult|number>} [rolls=[]] The roll results
     *
     * @throws {TypeError} Rolls must be an array
     */
    function RollResults() {
      var rolls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, RollResults);

      this.rolls = rolls;
    }
    /**
     * The number of roll results.
     *
     * @returns {number}
     */


    _createClass(RollResults, [{
      key: "length",
      get: function get() {
        return this.rolls.length || 0;
      }
      /**
       * List of roll results.
       *
       * @returns {RollResult[]}
       */

    }, {
      key: "rolls",
      get: function get() {
        return _toConsumableArray(this[rollsSymbol$1]);
      }
      /**
       * Set the rolls.
       *
       * @param {RollResult[]|number[]} rolls
       *
       * @throws {TypeError} Rolls must be an array
       */
      ,
      set: function set(rolls) {
        var _this = this;

        if (!rolls || !Array.isArray(rolls)) {
          // roll is not an array
          throw new TypeError("rolls must be an array: ".concat(rolls));
        } // loop through each result and add it to the rolls list


        this[rollsSymbol$1] = [];
        rolls.forEach(function (result) {
          _this.addRoll(result);
        });
      }
      /**
       * The total value of all the rolls after modifiers have been applied.
       *
       * @returns {number}
       */

    }, {
      key: "value",
      get: function get() {
        return this.rolls.reduce(function (v, roll) {
          return v + (roll.useInTotal ? roll.calculationValue : 0);
        }, 0);
      }
      /**
       * Add a single roll to the list.
       *
       * @param {RollResult|number} value
       */

    }, {
      key: "addRoll",
      value: function addRoll(value) {
        var result = value instanceof RollResult ? value : new RollResult(value);
        this[rollsSymbol$1].push(result);
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{rolls: RollResult[], value: number}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var rolls = this.rolls,
            value = this.value;
        return {
          rolls: rolls,
          type: 'roll-results',
          value: value
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        return "[".concat(this.rolls.join(', '), "]");
      }
    }]);

    return RollResults;
  }();

  var onceSymbol = Symbol('once');
  /**
   * A `ReRollModifier` re-rolls dice that match a given test, and replaces the new value with the old
   * one.
   *
   * @see {@link ExplodeModifier} if you want to keep the old value as well
   *
   * @extends ComparisonModifier
   */

  var ReRollModifier = /*#__PURE__*/function (_ComparisonModifier) {
    _inherits(ReRollModifier, _ComparisonModifier);

    var _super = _createSuper(ReRollModifier);

    /**
     * Create a `ReRollModifier` instance.
     *
     * @param {boolean} [once=false] Whether to only re-roll once or not
     * @param {ComparePoint} [comparePoint=null] The comparison object
     */
    function ReRollModifier() {
      var _this;

      var once = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var comparePoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, ReRollModifier);

      _this = _super.call(this, comparePoint);
      _this.once = !!once; // set the modifier's sort order

      _this.order = 4;
      return _this;
    }
    /* eslint-disable class-methods-use-this */

    /**
     * The name of the modifier.
     *
     * @returns {string} 're-roll'
     */


    _createClass(ReRollModifier, [{
      key: "name",
      get: function get() {
        return 're-roll';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "r".concat(this.once ? 'o' : '').concat(_get(_getPrototypeOf(ReRollModifier.prototype), "notation", this));
      }
      /**
       * Whether the modifier should only re-roll once or not.
       *
       * @returns {boolean} `true` if it should re-roll once, `false` otherwise
       */

    }, {
      key: "once",
      get: function get() {
        return !!this[onceSymbol];
      }
      /**
       * Set whether the modifier should only re-roll once or not.
       *
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this[onceSymbol] = !!value;
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        // ensure that the dice can explode without going into an infinite loop
        if (_context.min === _context.max) {
          throw new DieActionValueError(_context, 're-roll');
        }

        results.rolls.map(function (roll) {
          // re-roll if the value matches the compare point and we haven't reached the max iterations,
          // unless we're only rolling once and have already re-rolled
          for (var i = 0; i < _this2.maxIterations && _this2.isComparePoint(roll.value); i++) {
            // re-roll the dice
            var rollResult = _context.rollOnce(); // update the roll value (Unlike exploding, the original value is not kept)
            // eslint-disable-next-line no-param-reassign


            roll.value = rollResult.value; // add the re-roll modifier flag

            roll.modifiers.add("re-roll".concat(_this2.once ? '-once' : '')); // stop the loop if we're only re-rolling once

            if (_this2.once) {
              break;
            }
          }

          return roll;
        });
        return results;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  notation: string,
       *  name: string,
       *  type: string,
       *  comparePoint: (ComparePoint|undefined),
       *  once: boolean
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var once = this.once;
        return Object.assign(_get(_getPrototypeOf(ReRollModifier.prototype), "toJSON", this).call(this), {
          once: once
        });
      }
    }]);

    return ReRollModifier;
  }(ComparisonModifier);

  var modifiersSymbol$2 = Symbol('modifiers');
  var qtySymbol$1 = Symbol('qty');
  var sidesSymbol = Symbol('sides');
  var minSymbol$1 = Symbol('min-value');
  var maxSymbol$1 = Symbol('max-value');
  /**
   * Represents a standard numerical die.
   */

  var StandardDice = /*#__PURE__*/function () {
    /**
     * Create a `StandardDice` instance.
     *
     * @param {number} sides The number of sides the die has (.e.g `6`)
     * @param {number} [qty=1] The number of dice to roll (e.g. `4`)
     * @param {Map<string, Modifier>|Modifier[]|{}|null} [modifiers] The modifiers that affect the die
     * @param {number|null} [min=1] The minimum possible roll value
     * @param {number|null} [max=null] The maximum possible roll value. Defaults to number of `sides`
     *
     * @throws {RequiredArgumentError} sides is required
     * @throws {TypeError} qty must be a positive integer, and modifiers must be valid
     */
    function StandardDice(sides) {
      var qty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      _classCallCheck(this, StandardDice);

      if (!sides && sides !== 0) {
        throw new RequiredArgumentError('sides');
      } else if (sides === Infinity) {
        throw new RangeError('numerical sides must be finite number');
      } else if (isNumeric(sides)) {
        if (sides < 1 || !isSafeNumber(sides)) {
          throw new RangeError('numerical sides must be a positive finite number');
        }
      } else if (typeof sides !== 'string') {
        throw new TypeError('non-numerical sides must be a string');
      }

      if (!isNumeric(qty)) {
        throw new TypeError('qty must be a positive finite integer');
      } else if (qty < 1 || qty > 999) {
        throw new RangeError('qty must be between 1 and 999');
      }

      if (!isNumeric(min)) {
        throw new TypeError('min must a finite number');
      } else if (!isSafeNumber(min)) {
        throw new RangeError('min must a finite number');
      }

      if (max && !isNumeric(max)) {
        throw new TypeError('max must a finite number');
      } else if (max && !isSafeNumber(max)) {
        throw new RangeError('max must a finite number');
      }

      this[qtySymbol$1] = parseInt("".concat(qty), 10);
      this[sidesSymbol] = sides;

      if (modifiers) {
        this.modifiers = modifiers;
      }

      this[minSymbol$1] = parseInt(min, 10);
      this[maxSymbol$1] = max ? parseInt("".concat(max), 10) : sides;
    }
    /**
     * The average value that the die can roll (Excluding modifiers).
     *
     * @returns {number}
     */


    _createClass(StandardDice, [{
      key: "average",
      get: function get() {
        return (this.min + this.max) / 2;
      }
      /**
       * The modifiers that affect this die roll.
       *
       * @returns {Map<string, Modifier>|null}
       */

    }, {
      key: "modifiers",
      get: function get() {
        if (this[modifiersSymbol$2]) {
          // ensure modifiers are ordered correctly
          return new Map(_toConsumableArray(this[modifiersSymbol$2]).sort(function (a, b) {
            return a[1].order - b[1].order;
          }));
        }

        return null;
      }
      /**
       * Set the modifiers that affect this roll.
       *
       * @param {Map<string, Modifier>|Modifier[]|{}|null} value
       *
       * @throws {TypeError} Modifiers should be a Map, array of Modifiers, or an Object
       */
      ,
      set: function set(value) {
        var _this = this;

        var modifiers;

        if (value instanceof Map) {
          modifiers = value;
        } else if (Array.isArray(value)) {
          // loop through and get the modifier name of each item and use it as the map key
          modifiers = new Map(value.map(function (modifier) {
            return [modifier.name, modifier];
          }));
        } else if (_typeof(value) === 'object') {
          modifiers = new Map(Object.entries(value));
        } else {
          throw new TypeError('modifiers should be a Map, array, or an Object containing Modifiers');
        }

        if (modifiers.size && _toConsumableArray(modifiers.entries()).some(function (entry) {
          return !(entry[1] instanceof Modifier);
        })) {
          throw new TypeError('modifiers must only contain Modifier instances');
        }

        this[modifiersSymbol$2] = modifiers; // loop through each modifier and ensure that those that require it have compare points
        // @todo find a better way of defining compare point on modifiers that don't have them

        /* eslint-disable no-param-reassign */

        this[modifiersSymbol$2].forEach(function (modifier) {
          if (modifier instanceof ExplodeModifier && !modifier.comparePoint) {
            modifier.comparePoint = new ComparePoint('=', _this.max);
          } else if (modifier instanceof ReRollModifier && !modifier.comparePoint) {
            modifier.comparePoint = new ComparePoint('=', _this.min);
          }
        });
        /* eslint-enable */
      }
      /**
       * The maximum value that can be rolled on the die, excluding modifiers.
       *
       * @returns {number}
       */

    }, {
      key: "max",
      get: function get() {
        return this[maxSymbol$1];
      }
      /**
       * The minimum value that can be rolled on the die, excluding modifiers.
       *
       * @returns {number}
       */

    }, {
      key: "min",
      get: function get() {
        return this[minSymbol$1];
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the die.
       *
       * @returns {string} 'standard'
       */

    }, {
      key: "name",
      get: function get() {
        return 'standard';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The dice notation. e.g. `4d6!`.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        var notation = "".concat(this.qty, "d").concat(this.sides);

        if (this.modifiers && this.modifiers.size) {
          notation += _toConsumableArray(this.modifiers.values()).reduce(function (acc, modifier) {
            return acc + modifier.notation;
          }, '');
        }

        return notation;
      }
      /**
       * The number of dice that should be rolled.
       *
       * @returns {number}
       */

    }, {
      key: "qty",
      get: function get() {
        return this[qtySymbol$1];
      }
      /**
       * The number of sides the die has.
       *
       * @returns {number}
       */

    }, {
      key: "sides",
      get: function get() {
        return this[sidesSymbol];
      }
      /**
       * Roll the dice for the specified quantity and apply any modifiers.
       *
       * @returns {RollResults} The result of the roll
       */

    }, {
      key: "roll",
      value: function roll() {
        var _this2 = this;

        // create a result object to hold the rolls
        var rollResult = new RollResults(); // loop for the quantity and roll the die

        for (var i = 0; i < this.qty; i++) {
          // add the rolls to the list
          rollResult.addRoll(this.rollOnce());
        } // loop through each modifier and carry out its actions


        (this.modifiers || []).forEach(function (modifier) {
          modifier.run(rollResult, _this2);
        });
        return rollResult;
      }
      /**
       * Roll a single die and return the value.
       *
       * @returns {RollResult} The value rolled
       */

    }, {
      key: "rollOnce",
      value: function rollOnce() {
        return new RollResult(generator.integer(this.min, this.max));
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  average: number,
       *  min: number,
       *  max: number,
       *  notation: string,
       *  qty: number,
       *  name: string,
       *  sides: number,
       *  modifiers: (Map<string, Modifier>|null),
       *  type: string
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var average = this.average,
            max = this.max,
            min = this.min,
            modifiers = this.modifiers,
            name = this.name,
            notation = this.notation,
            qty = this.qty,
            sides = this.sides;
        return {
          average: average,
          max: max,
          min: min,
          modifiers: modifiers,
          name: name,
          notation: notation,
          qty: qty,
          sides: sides,
          type: 'die'
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @see {@link StandardDice#notation}
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.notation;
      }
    }]);

    return StandardDice;
  }();

  /**
   * Represents a Fudge / Fate type die.
   *
   * @extends StandardDice
   */

  var FudgeDice = /*#__PURE__*/function (_StandardDice) {
    _inherits(FudgeDice, _StandardDice);

    var _super = _createSuper(FudgeDice);

    /**
     * Create a `FudgeDice` instance.
     *
     * @param {number} [nonBlanks=2] The number of sides each symbol should cover (`1` or `2`)
     * @param {number} [qty=1] The number of dice to roll (e.g. `4`)
     * @param {Map<string, Modifier>|Modifier[]|{}|null} [modifiers] The modifiers that affect the die
     *
     * @throws {RangeError} nonBlanks must be 1 or 2
     * @throws {TypeError} modifiers must be valid
     */
    function FudgeDice() {
      var nonBlanks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
      var qty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, FudgeDice);

      var numNonBlanks = nonBlanks;

      if (!numNonBlanks && numNonBlanks !== 0) {
        numNonBlanks = 2;
      } else if (numNonBlanks !== 1 && numNonBlanks !== 2) {
        throw new RangeError('nonBlanks must be 1 or 2');
      }

      return _super.call(this, numNonBlanks, qty, modifiers, -1, 1);
    }
    /* eslint-disable class-methods-use-this */

    /**
     * The name of the die.
     *
     * @returns {string} 'fudge'
     */


    _createClass(FudgeDice, [{
      key: "name",
      get: function get() {
        return 'fudge';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The number of sides that each symbol (+, -) covers.
       *
       * @returns {number} `1` or `2`
       */

    }, {
      key: "nonBlanks",
      get: function get() {
        return _get(_getPrototypeOf(FudgeDice.prototype), "sides", this);
      }
      /**
       * The number of sides the die has.
       *
       * @returns {string} 'F.2' or 'F.1'
       */

    }, {
      key: "sides",
      get: function get() {
        return "F.".concat(this.nonBlanks);
      }
      /**
       * Roll a single die and return the value.
       *
       * @returns {RollResult} The value rolled
       */

    }, {
      key: "rollOnce",
      value: function rollOnce() {
        var total = 0;

        if (this.nonBlanks === 2) {
          // default fudge (2 of each non-blank) = 1d3 - 2
          total = generator.integer(1, 3) - 2;
        } else if (this.nonBlanks === 1) {
          // only 1 of each non-blank
          // on 1d6 a roll of 1 = -1, 6 = +1, others = 0
          var num = generator.integer(1, 6);

          if (num === 1) {
            total = -1;
          } else if (num === 6) {
            total = 1;
          }
        }

        return new RollResult(total);
      }
    }]);

    return FudgeDice;
  }(StandardDice);

  /**
   * Represents a percentile die.
   *
   * @extends StandardDice
   */

  var PercentileDice = /*#__PURE__*/function (_StandardDice) {
    _inherits(PercentileDice, _StandardDice);

    var _super = _createSuper(PercentileDice);

    /**
     * Create a `PercentileDice` instance.
     *
     * @param {number} [qty=1] The number of dice to roll (e.g. `4`)
     * @param {Map<string, Modifier>|Modifier[]|{}|null} [modifiers] The modifiers that affect the die
     * @param {boolean} [sidesAsNumber=false] Whether to show the sides as `%` (default) or `100`
     *
     * @throws {TypeError} qty must be a positive integer, and modifiers must be valid
     */
    function PercentileDice() {
      var _this;

      var qty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sidesAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _classCallCheck(this, PercentileDice);

      _this = _super.call(this, 100, qty, modifiers);
      _this.sidesAsNumber = !!sidesAsNumber;
      return _this;
    }
    /* eslint-disable class-methods-use-this */

    /**
     * The name of the die.
     *
     * @returns {string} 'percentile'
     */


    _createClass(PercentileDice, [{
      key: "name",
      get: function get() {
        return 'percentile';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The number of sides the die has
       *
       * @returns {number|string} `%` if `sidesAsNumber == false`, or `100` otherwise
       */

    }, {
      key: "sides",
      get: function get() {
        return this.sidesAsNumber ? _get(_getPrototypeOf(PercentileDice.prototype), "sides", this) : '%';
      }
    }]);

    return PercentileDice;
  }(StandardDice);

  var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FudgeDice: FudgeDice,
    PercentileDice: PercentileDice,
    StandardDice: StandardDice
  });

  /**
   * A `CriticalFailureModifier` modifier flags values that match a comparison.
   *
   * Unlike most other modifiers, it doesn't affect the roll value, it simply "flags" matching rolls.
   *
   * @see {@link CriticalSuccessModifier} for the opposite of this modifier
   *
   * @extends ComparisonModifier
   */

  var CriticalFailureModifier = /*#__PURE__*/function (_ComparisonModifier) {
    _inherits(CriticalFailureModifier, _ComparisonModifier);

    var _super = _createSuper(CriticalFailureModifier);

    /**
     * Create a `CriticalFailureModifier` instance.
     *
     * @param {ComparePoint} [comparePoint] The comparison object
     *
     * @throws {TypeError} comparePoint must be a `ComparePoint` object
     */
    function CriticalFailureModifier(comparePoint) {
      var _this;

      _classCallCheck(this, CriticalFailureModifier);

      _this = _super.call(this, comparePoint); // set the modifier's sort order

      _this.order = 9;
      return _this;
    }
    /* eslint-disable class-methods-use-this */

    /**
     * The name of the modifier.
     *
     * @returns {string} 'critical-failure'
     */


    _createClass(CriticalFailureModifier, [{
      key: "name",
      get: function get() {
        return 'critical-failure';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "cf".concat(_get(_getPrototypeOf(CriticalFailureModifier.prototype), "notation", this));
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        results.rolls.forEach(function (roll) {
          // add the modifier flag
          if (_this2.isComparePoint(roll.value)) {
            roll.modifiers.add('critical-failure');
          }

          return roll;
        });
        return results;
      }
    }]);

    return CriticalFailureModifier;
  }(ComparisonModifier);

  /**
   * A `CriticalSuccessModifier` modifier flags values that match a comparison.
   *
   * Unlike most other modifiers, it doesn't affect the roll value, it simply "flags" matching rolls.
   *
   * @see {@link CriticalFailureModifier} for the opposite of this modifier
   *
   * @extends ComparisonModifier
   */

  var CriticalSuccessModifier = /*#__PURE__*/function (_ComparisonModifier) {
    _inherits(CriticalSuccessModifier, _ComparisonModifier);

    var _super = _createSuper(CriticalSuccessModifier);

    /**
     * Create a `CriticalSuccessModifier` instance.
     *
     * @param {ComparePoint} comparePoint The comparison object
     *
     * @throws {TypeError} comparePoint must be a `ComparePoint` object
     */
    function CriticalSuccessModifier(comparePoint) {
      var _this;

      _classCallCheck(this, CriticalSuccessModifier);

      _this = _super.call(this, comparePoint); // set the modifier's sort order

      _this.order = 8;
      return _this;
    }
    /* eslint-disable class-methods-use-this */

    /**
     * The name of the modifier.
     *
     * @returns {string} 'critical-success'
     */


    _createClass(CriticalSuccessModifier, [{
      key: "name",
      get: function get() {
        return 'critical-success';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "cs".concat(_get(_getPrototypeOf(CriticalSuccessModifier.prototype), "notation", this));
      }
      /**
       * Runs the modifier on the rolls.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults}
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        // loop through each roll and see if it's a critical success
        results.rolls.forEach(function (roll) {
          // add the modifier flag
          if (_this2.isComparePoint(roll.value)) {
            roll.modifiers.add('critical-success');
          }

          return roll;
        });
        return results;
      }
    }]);

    return CriticalSuccessModifier;
  }(ComparisonModifier);

  var calculationValueSymbol = Symbol('calculation-value');
  var isRollGroupSymbol = Symbol('is-roll-group');
  var modifiersSymbol$1 = Symbol('modifiers');
  var resultsSymbol = Symbol('results');
  var useInTotalSymbol = Symbol('use-in-total');
  /**
   * A collection of results and expressions.
   * Usually used to represent the results of a `RollGroup` instance.
   *
   * This can contain `ResultGroup`, `RollResults`, operators, and plain numbers.
   *
   * ::: tip
   * You will probably not need to create your own `ResultGroup` instances, unless you're importing
   * rolls, but `ResultGroup` objects will be returned when rolling group rolls.
   * :::
   *
   * @since 4.5.0
   */

  var ResultGroup = /*#__PURE__*/function () {
    /**
     * Create a `ResultGroup` instance.
     *
     * @example <caption>Normal roll: `4d6+2d10`</caption>
     * const results = new ResultGroup([
     *  new RollResults([3, 5, 4, 2]),
     *  '+',
     *  new RollResults([4, 8]),
     * ]);
     *
     * @example <caption>Roll group: `{4d6+2d10/2, 5d6/2d%}`</caption>
     * const results = new ResultGroup([
     *  new ResultGroup([
     *    new RollResults([3, 5, 4, 2]),
     *    '+',
     *    new RollResults([4, 8]),
     *    '/',
     *    2,
     *  ]),
     *  new ResultGroup([
     *    new RollResults([3, 3, 5, 2, 4]),
     *    '/',
     *    new RollResults([87, 46]),
     *  ]),
     * ]);
     *
     * @param {Array.<ResultGroup|RollResults|number|string>} [results=[]] The results and expressions
     * @param {string[]|Set<string>} [modifiers=[]] List of modifier names that affect the group
     * @param {boolean} [isRollGroup=false] Whether the result group represents a roll group or not
     * @param {boolean} [useInTotal=true] Whether to include the group's value when calculating totals
     *
     * @throws {TypeError} Rolls must be an array
     */
    function ResultGroup() {
      var results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var isRollGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var useInTotal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      _classCallCheck(this, ResultGroup);

      this.isRollGroup = isRollGroup;
      this.modifiers = modifiers;
      this.results = results;
      this.useInTotal = useInTotal;
    }
    /**
     * The value to use in calculations.
     * This may be changed by modifiers.
     *
     * @returns {number}
     */


    _createClass(ResultGroup, [{
      key: "calculationValue",
      get: function get() {
        return isNumeric(this[calculationValueSymbol]) ? parseFloat(this[calculationValueSymbol]) : this.value;
      }
      /**
       * Set the value to use in calculations.
       *
       * @param {number} value
       *
       * @throws {TypeError} value is invalid
       */
      ,
      set: function set(value) {
        var isValNumeric = isNumeric(value);

        if (value === Infinity) {
          throw new RangeError('Results calculation value must be a finite number');
        }

        if (value && !isValNumeric) {
          throw new TypeError("Results calculation value is invalid: ".concat(value));
        }

        this[calculationValueSymbol] = isValNumeric ? parseFloat("".concat(value)) : null;
      }
      /**
       * Whether the result group represents a roll group or not.
       *
       * @returns {boolean} `true` if it is a roll group, `false` otherwise
       */

    }, {
      key: "isRollGroup",
      get: function get() {
        return this[isRollGroupSymbol];
      }
      /**
       * Set whether the result group represents a roll group or not.
       *
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this[isRollGroupSymbol] = !!value;
      }
      /**
       * The number of results.
       *
       * @returns {number}
       */

    }, {
      key: "length",
      get: function get() {
        return this.results.length || 0;
      }
      /**
       * The visual flags for the modifiers that affect the group.
       *
       * @see {@link ResultGroup#modifiers}
       *
       * @returns {string}
       */

    }, {
      key: "modifierFlags",
      get: function get() {
        return getModifierFlags.apply(void 0, _toConsumableArray(this.modifiers));
      }
      /**
       * The modifier names that affect the group.
       *
       * @returns {Set<string>}
       */

    }, {
      key: "modifiers",
      get: function get() {
        return this[modifiersSymbol$1];
      }
      /**
       * Set the modifier names that affect the group.
       *
       * @example
       * resultGroup.modifiers = ['drop', 'target-success'];
       *
       * @param {string[]|Set<string>} value
       *
       * @throws {TypeError} modifiers must be a Set or array of modifier names
       */
      ,
      set: function set(value) {
        if ((Array.isArray(value) || value instanceof Set) && _toConsumableArray(value).every(function (item) {
          return typeof item === 'string';
        })) {
          this[modifiersSymbol$1] = new Set(_toConsumableArray(value));
        } else if (!value && value !== 0) {
          // clear the modifiers
          this[modifiersSymbol$1] = new Set();
        } else {
          throw new TypeError("modifiers must be a Set or array of modifier names: ".concat(value));
        }
      }
      /**
       * List of results.
       *
       * @returns {Array.<ResultGroup|RollResults|number|string>}
       */

    }, {
      key: "results",
      get: function get() {
        return _toConsumableArray(this[resultsSymbol]);
      }
      /**
       * Set the results.
       *
       * @param {Array.<ResultGroup|RollResults|number|string>} results
       *
       * @throws {TypeError} Results must be an array
       */
      ,
      set: function set(results) {
        var _this = this;

        if (!results || !Array.isArray(results)) {
          // results is not an array
          throw new TypeError("results must be an array: ".concat(results));
        } // loop through each result and add it to the results list


        this[resultsSymbol] = [];
        results.forEach(function (result) {
          _this.addResult(result);
        });
      }
      /**
       * Whether to use the value in total calculations or not.
       *
       * @returns {boolean}
       */

    }, {
      key: "useInTotal",
      get: function get() {
        return !!this[useInTotalSymbol];
      }
      /**
       * Set whether to use the value in total calculations or not.
       *
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this[useInTotalSymbol] = !!value;
      }
      /**
       * The total value of all the results after modifiers have been applied.
       *
       * @returns {number}
       */

    }, {
      key: "value",
      get: function get() {
        if (!this.results.length) {
          return 0;
        } // loop through the results
        // - get the values of result objects and add any operators and plain numbers
        // we'll either end up with a numerical total (If all results are result objects or numbers)
        // or a string equation (If there are operators)


        var value = this.results.reduce(function (v, result) {
          var val = result;

          if (result instanceof ResultGroup) {
            val = result.useInTotal ? result.calculationValue : 0;
          } else if (result instanceof RollResults) {
            val = result.value;
          }

          return v + val;
        }, typeof this.results[0] === 'string' ? '' : 0); // if value is a string that means operators were included, so we need to evaluate the equation

        if (typeof value === 'string') {
          return evaluate(value);
        }

        return value;
      }
      /**
       * Add a single result to the list.
       *
       * @param {ResultGroup|RollResults|number|string} value
       *
       * @throws {TypeError} Value type is invalid
       */

    }, {
      key: "addResult",
      value: function addResult(value) {
        var val;

        if (value instanceof ResultGroup || value instanceof RollResults) {
          // already a valid result object
          val = value;
        } else if (typeof value === 'string' || isNumeric(value)) {
          // string operator (e.g. '+', '/', etc.), or plain number
          val = value;
        } else {
          throw new TypeError('value must be one of ResultGroup, RollResults, string, or number');
        } // add the result to the list


        this[resultsSymbol].push(val);
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  modifierFlags: string,
       *  modifiers: string[],
       *  results: Array<ResultGroup|RollResults|number|string>,
       *  type: string,
       *  useInTotal: boolean,
       *  value: number
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var calculationValue = this.calculationValue,
            isRollGroup = this.isRollGroup,
            modifierFlags = this.modifierFlags,
            modifiers = this.modifiers,
            results = this.results,
            useInTotal = this.useInTotal,
            value = this.value;
        return {
          calculationValue: calculationValue,
          isRollGroup: isRollGroup,
          modifierFlags: modifierFlags,
          modifiers: _toConsumableArray(modifiers),
          results: results,
          type: 'result-group',
          useInTotal: useInTotal,
          value: value
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        var output;

        if (this.isRollGroup) {
          output = "{".concat(this.results.join(', '), "}");
        } else {
          output = this.results.join('');
        }

        if (this.modifierFlags) {
          output = "(".concat(output, ")").concat(this.modifierFlags);
        }

        return output;
      }
    }]);

    return ResultGroup;
  }();

  var endSymbol = Symbol('end');
  var qtySymbol = Symbol('qty');
  /**
   * A `KeepModifier` will "keep" dice from a roll, dropping (Remove from total calculations) all
   * others.
   *
   * @see {@link DropModifier} for the opposite of this modifier
   *
   * @extends Modifier
   */

  var KeepModifier = /*#__PURE__*/function (_Modifier) {
    _inherits(KeepModifier, _Modifier);

    var _super = _createSuper(KeepModifier);

    /**
     * Create a `KeepModifier` instance
     *
     * @param {string} [end=h] Either `h|l` to keep highest or lowest
     * @param {number} [qty=1] The amount dice to keep
     *
     * @throws {RangeError} End must be one of 'h' or 'l'
     * @throws {TypeError} qty must be a positive integer
     */
    function KeepModifier() {
      var _this;

      var end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'h';
      var qty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      _classCallCheck(this, KeepModifier);

      _this = _super.call(this);
      _this.end = end;
      _this.qty = qty; // set the modifier's sort order

      _this.order = 5;
      return _this;
    }
    /**
     * Which end the rolls should be kept ("h" = High, "l" = Low).
     *
     * @returns {string} 'h' or 'l'
     */


    _createClass(KeepModifier, [{
      key: "end",
      get: function get() {
        return this[endSymbol];
      }
      /**
       * Set which end the rolls should be kept ("h" = High, "l" = Low).
       *
       * @param {string} value Either 'h' or 'l'
       *
       * @throws {RangeError} End must be one of 'h' or 'l'
       */
      ,
      set: function set(value) {
        if (value !== 'h' && value !== 'l') {
          throw new RangeError('End must be "h" or "l"');
        }

        this[endSymbol] = value;
      }
      /**
       * The name of the modifier.
       *
       * @returns {string} 'keep-l' or 'keep-h'
       */

    }, {
      key: "name",
      get: function get() {
        return "keep-".concat(this.end);
      }
      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "k".concat(this.end).concat(this.qty);
      }
      /**
       * The quantity of dice that should be kept.
       *
       * @returns {number}
       */

    }, {
      key: "qty",
      get: function get() {
        return this[qtySymbol];
      }
      /**
       * Set the quantity of dice that should be kept.
       *
       * @param {number} value
       *
       * @throws {TypeError} qty must be a positive finite integer
       */
      ,
      set: function set(value) {
        if (value === Infinity) {
          throw new RangeError('qty must be a finite number');
        }

        if (!isNumeric(value) || value < 1) {
          throw new TypeError('qty must be a positive finite integer');
        }

        this[qtySymbol] = Math.floor(value);
      }
      /**
       * Determine the start and end (end exclusive) range of rolls to drop.
       *
       * @param {RollResults} _results The results to drop from
       *
       * @returns {number[]} The min / max range to drop
       */

    }, {
      key: "rangeToDrop",
      value: function rangeToDrop(_results) {
        // we're keeping, so we want to drop all dice that are outside of the qty range
        if (this.end === 'h') {
          return [0, _results.length - this.qty];
        }

        return [this.qty, _results.length];
      }
      /**
       * Run the modifier on the results.
       *
       * @param {ResultGroup|RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {ResultGroup|RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _rollIndexes$sort$map;

        var modifiedRolls;
        var rollIndexes;

        if (results instanceof ResultGroup) {
          modifiedRolls = results.results;

          if (modifiedRolls.length === 1 && modifiedRolls[0] instanceof ResultGroup) {
            // single sub-roll - get all the dice rolled and their 2d indexes
            rollIndexes = modifiedRolls[0].results.map(function (result, index) {
              if (result instanceof RollResults) {
                return result.rolls.map(function (subResult, subIndex) {
                  return {
                    value: subResult.value,
                    index: [index, subIndex]
                  };
                });
              }

              return null;
            }).flat().filter(Boolean);
          } else {
            rollIndexes = _toConsumableArray(modifiedRolls) // get a list of objects with roll values and original index
            .map(function (roll, index) {
              return {
                value: roll.value,
                index: index
              };
            });
          }
        } else {
          modifiedRolls = results.rolls;
          rollIndexes = _toConsumableArray(modifiedRolls) // get a list of objects with roll values and original index
          .map(function (roll, index) {
            return {
              value: roll.value,
              index: index
            };
          });
        } // determine the indexes that need to be dropped


        rollIndexes = (_rollIndexes$sort$map = rollIndexes // sort the list ascending by value
        .sort(function (a, b) {
          return a.value - b.value;
        }).map(function (rollIndex) {
          return rollIndex.index;
        }) // get the roll indexes to drop
        ).slice.apply(_rollIndexes$sort$map, _toConsumableArray(this.rangeToDrop(rollIndexes))); // loop through all of our dice to drop and flag them as such

        rollIndexes.forEach(function (rollIndex) {
          var roll;

          if (Array.isArray(rollIndex)) {
            // array of indexes (e.g. single sub-roll in a group roll)
            roll = modifiedRolls[0].results[rollIndex[0]].rolls[rollIndex[1]];
          } else {
            roll = modifiedRolls[rollIndex];
          }

          roll.modifiers.add('drop');
          roll.useInTotal = false;
        });
        return results;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{notation: string, name: string, type: string, qty: number, end: string}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var end = this.end,
            qty = this.qty;
        return Object.assign(_get(_getPrototypeOf(KeepModifier.prototype), "toJSON", this).call(this), {
          end: end,
          qty: qty
        });
      }
    }]);

    return KeepModifier;
  }(Modifier);

  /**
   * A `DropModifier` will "drop" (Remove from total calculations) dice from a roll.
   *
   * @see {@link KeepModifier} for the opposite of this modifier
   *
   * @extends KeepModifier
   */

  var DropModifier = /*#__PURE__*/function (_KeepModifier) {
    _inherits(DropModifier, _KeepModifier);

    var _super = _createSuper(DropModifier);

    /**
     * Create a `DropModifier` instance.
     *
     * @param {string} [end=l] Either `h|l` to drop highest or lowest
     * @param {number} [qty=1] The amount of dice to drop
     *
     * @throws {RangeError} End must be one of 'h' or 'l'
     * @throws {TypeError} qty must be a positive integer
     */
    function DropModifier() {
      var _this;

      var end = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'l';
      var qty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      _classCallCheck(this, DropModifier);

      _this = _super.call(this, end, qty); // set the modifier's sort order

      _this.order = 6;
      return _this;
    }
    /**
     * The name of the modifier.
     *
     * @returns {string} 'drop-l' or 'drop-h'
     */


    _createClass(DropModifier, [{
      key: "name",
      get: function get() {
        return "drop-".concat(this.end);
      }
      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "d".concat(this.end).concat(this.qty);
      }
      /**
       * Determine the start and end (end exclusive) range of rolls to drop.
       *
       * @param {RollResults} _results The results to drop from
       *
       * @returns {number[]} The min / max range to drop
       */

    }, {
      key: "rangeToDrop",
      value: function rangeToDrop(_results) {
        // we're dropping, so we want to drop all dice that are inside of the qty range
        if (this.end === 'h') {
          return [_results.length - this.qty, _results.length];
        }

        return [0, this.qty];
      }
    }]);

    return DropModifier;
  }(KeepModifier);

  var maxSymbol = Symbol('max');
  /**
   * A `MaxModifier` causes die rolls over a maximum value to be treated as the maximum value.
   *
   * @since 4.3.0
   *
   * @see {@link MinModifier} for the opposite of this modifier
   *
   * @extends {Modifier}
   */

  var MaxModifier = /*#__PURE__*/function (_Modifier) {
    _inherits(MaxModifier, _Modifier);

    var _super = _createSuper(MaxModifier);

    /**
     * Create a `MaxModifier` instance.
     *
     * @param {number} max The maximum value
     *
     * @throws {TypeError} max must be a number
     */
    function MaxModifier(max) {
      var _this;

      _classCallCheck(this, MaxModifier);

      _this = _super.call(this);
      _this.max = max; // set the modifier's sort order

      _this.order = 2;
      return _this;
    }
    /**
     * The maximum value.
     *
     * @returns {Number}
     */


    _createClass(MaxModifier, [{
      key: "max",
      get: function get() {
        return this[maxSymbol];
      }
      /**
       * Set the maximum value.
       *
       * @param {number} value
       *
       * @throws {TypeError} max must be a number
       */
      ,
      set: function set(value) {
        if (!isNumeric(value)) {
          throw new TypeError('max must be a number');
        }

        this[maxSymbol] = parseFloat("".concat(value));
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the modifier.
       *
       * @returns {string} 'max'
       */

    }, {
      key: "name",
      get: function get() {
        return 'max';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "max".concat(this.max);
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        var parsedResults = results;
        parsedResults.rolls = results.rolls.map(function (roll) {
          var parsedRoll = roll;

          if (roll.value > _this2.max) {
            parsedRoll.value = _this2.max;
            parsedRoll.modifiers.add('max');
          }

          return parsedRoll;
        });
        return parsedResults;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{notation: string, name: string, type: string, max: Number}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var max = this.max;
        return Object.assign(_get(_getPrototypeOf(MaxModifier.prototype), "toJSON", this).call(this), {
          max: max
        });
      }
    }]);

    return MaxModifier;
  }(Modifier);

  var minSymbol = Symbol('min');
  /**
   * A `MinModifier` causes die rolls under a minimum value to be treated as the minimum value.
   *
   * @since 4.3.0
   *
   * @see {@link MaxModifier} for the opposite of this modifier
   *
   * @extends {Modifier}
   */

  var MinModifier = /*#__PURE__*/function (_Modifier) {
    _inherits(MinModifier, _Modifier);

    var _super = _createSuper(MinModifier);

    /**
     * Create a `MinModifier` instance.
     *
     * @param {number} min The minimum value
     *
     * @throws {TypeError} min must be a number
     */
    function MinModifier(min) {
      var _this;

      _classCallCheck(this, MinModifier);

      _this = _super.call(this);
      _this.min = min; // set the modifier's sort order

      _this.order = 1;
      return _this;
    }
    /**
     * The minimum value.
     *
     * @returns {Number}
     */


    _createClass(MinModifier, [{
      key: "min",
      get: function get() {
        return this[minSymbol];
      }
      /**
       * Set the minimum value.
       *
       * @param {number} value
       *
       * @throws {TypeError} min must be a number
       */
      ,
      set: function set(value) {
        if (!isNumeric(value)) {
          throw new TypeError('min must be a number');
        }

        this[minSymbol] = parseFloat("".concat(value));
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the modifier.
       *
       * @returns {string} 'min'
       */

    }, {
      key: "name",
      get: function get() {
        return 'min';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "min".concat(this.min);
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        var parsedResults = results;
        parsedResults.rolls = results.rolls.map(function (roll) {
          var parsedRoll = roll;

          if (roll.value < _this2.min) {
            parsedRoll.value = _this2.min;
            parsedRoll.modifiers.add('min');
          }

          return parsedRoll;
        });
        return parsedResults;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{notation: string, name: string, type: string, min: Number}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var min = this.min;
        return Object.assign(_get(_getPrototypeOf(MinModifier.prototype), "toJSON", this).call(this), {
          min: min
        });
      }
    }]);

    return MinModifier;
  }(Modifier);

  var directionSymbol = Symbol('direction');
  /**
   * A `SortingModifier` sorts roll results by their value, either ascending or descending.
   *
   * @extends ComparisonModifier
   */

  var SortingModifier = /*#__PURE__*/function (_Modifier) {
    _inherits(SortingModifier, _Modifier);

    var _super = _createSuper(SortingModifier);

    /**
     * Create a `SortingModifier` instance.
     *
     * @param {string} [direction=a] The direction to sort in; 'a' (Ascending) or 'd' (Descending)
     *
     * @throws {RangeError} Direction must be 'a' or 'd'
     */
    function SortingModifier() {
      var _this;

      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'a';

      _classCallCheck(this, SortingModifier);

      _this = _super.call(this);
      _this.direction = direction; // set the modifier's sort order

      _this.order = 10;
      return _this;
    }
    /**
     * The sort direction.
     *
     * @returns {string} Either 'a' or 'd'
     */


    _createClass(SortingModifier, [{
      key: "direction",
      get: function get() {
        return this[directionSymbol];
      }
      /**
       * Set the sort direction.
       *
       * @param {string} value Either 'a' (Ascending) or 'd' (Descending)
       *
       * @throws {RangeError} Direction must be 'a' or 'd'
       */
      ,
      set: function set(value) {
        if (value !== 'a' && value !== 'd') {
          throw new RangeError('Direction must be "a" (Ascending) or "d" (Descending)');
        }

        this[directionSymbol] = value;
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the modifier.
       *
       * @returns {string} 'sorting'
       */

    }, {
      key: "name",
      get: function get() {
        return 'sorting';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "s".concat(this.direction);
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        var resultsKey;

        if (results instanceof ResultGroup) {
          resultsKey = 'results';
        } else {
          resultsKey = 'rolls';
        }
        /* eslint-disable no-param-reassign */


        results[resultsKey] = results[resultsKey].sort(function (a, b) {
          if (_this2.direction === 'd') {
            return b.value - a.value;
          }

          return a.value - b.value;
        }); // if result group, we also need to sort any die rolls in th sub-rolls

        if (results instanceof ResultGroup) {
          results[resultsKey] = results[resultsKey].map(function (subRoll) {
            if (subRoll instanceof ResultGroup || subRoll instanceof RollResults) {
              return _this2.run(subRoll, _context);
            }

            return subRoll;
          });
        }
        /* eslint-enable */


        return results;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{notation: string, name: string, type: string, direction: string}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var direction = this.direction;
        return Object.assign(_get(_getPrototypeOf(SortingModifier.prototype), "toJSON", this).call(this), {
          direction: direction
        });
      }
    }]);

    return SortingModifier;
  }(Modifier);

  var failureCPSymbol = Symbol('failure-cp');
  /**
   * A `TargetModifier` determines whether rolls are classed as a success, failure, or neutral.
   *
   * This modifies the roll values, depending on the state;
   *
   * success = `1`, failure = `-1`, neutral = `0`.
   *
   * @extends ComparisonModifier
   */

  var TargetModifier = /*#__PURE__*/function (_ComparisonModifier) {
    _inherits(TargetModifier, _ComparisonModifier);

    var _super = _createSuper(TargetModifier);

    /**
     * Create a `TargetModifier` instance.
     *
     * @param {ComparePoint} successCP The success comparison object
     * @param {ComparePoint} [failureCP=null] The failure comparison object
     *
     * @throws {TypeError} failure comparePoint must be instance of ComparePoint or null
     */
    function TargetModifier(successCP) {
      var _this;

      var failureCP = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, TargetModifier);

      _this = _super.call(this, successCP); // set the failure compare point

      _this.failureComparePoint = failureCP; // set the modifier's sort order

      _this.order = 7;
      return _this;
    }
    /**
     * The failure compare point for the modifier
     *
     * @returns {ComparePoint|null}
     */


    _createClass(TargetModifier, [{
      key: "failureComparePoint",
      get: function get() {
        return this[failureCPSymbol];
      }
      /**
       * Set the failure compare point
       *
       * @param {ComparePoint|null} comparePoint
       *
       * @throws {TypeError} failure comparePoint must be instance of ComparePoint or null
       */
      ,
      set: function set(comparePoint) {
        if (comparePoint && !(comparePoint instanceof ComparePoint)) {
          throw new TypeError('failure comparePoint must be instance of ComparePoint or null');
        }

        this[failureCPSymbol] = comparePoint || null;
      }
      /* eslint-disable class-methods-use-this */

      /**
       * The name of the modifier.
       *
       * @returns {string} 'target'
       */

    }, {
      key: "name",
      get: function get() {
        return 'target';
      }
      /* eslint-enable class-methods-use-this */

      /**
       * The modifier's notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return "".concat(_get(_getPrototypeOf(TargetModifier.prototype), "notation", this)).concat(this.failureComparePoint ? "f".concat(this.failureComparePoint) : '');
      }
      /**
       * The success compare point for the modifier
       *
       * @returns {ComparePoint}
       */

    }, {
      key: "successComparePoint",
      get: function get() {
        return this.comparePoint;
      }
      /**
       * Set the success compare point for the modifier
       *
       * @param {ComparePoint} value
       */
      ,
      set: function set(value) {
        _set(_getPrototypeOf(TargetModifier.prototype), "comparePoint", value, this, true);
      }
      /**
       * Check if the value is a success/failure/neither and return the corresponding state value.
       *
       * @param {number} value The number to compare against
       *
       * @returns {number} success = `1`, failure = `-1`, neutral = `0`
       */

    }, {
      key: "getStateValue",
      value: function getStateValue(value) {
        if (this.isSuccess(value)) {
          return 1;
        }

        if (this.isFailure(value)) {
          return -1;
        }

        return 0;
      }
      /**
       * Check if the `value` matches the failure compare point.
       *
       * A response of `false` does _NOT_ indicate a success.
       * A value is a success _ONLY_ if it passes the success compare point.
       * A value could be neither a failure or a success.
       *
       * @param {number} value The number to compare against
       *
       * @returns {boolean}
       */

    }, {
      key: "isFailure",
      value: function isFailure(value) {
        return this.failureComparePoint ? this.failureComparePoint.isMatch(value) : false;
      }
      /**
       * Check if the `value` is neither a success or a failure.
       *
       * @param {number} value The number to compare against
       *
       * @returns {boolean} `true` if the value doesn't match the success and failure compare points
       */

    }, {
      key: "isNeutral",
      value: function isNeutral(value) {
        return !this.isSuccess(value) && !this.isFailure(value);
      }
      /**
       * Check if the `value` matches the success compare point.
       *
       * A response of `false` does _NOT_ indicate a failure.
       * A value is a failure _ONLY_ if it passes the failure compare point.
       * A value could be neither a failure or a success.
       *
       * @param {number} value The number to compare against
       *
       * @returns {boolean}
       */

    }, {
      key: "isSuccess",
      value: function isSuccess(value) {
        return this.isComparePoint(value);
      }
      /**
       * Run the modifier on the results.
       *
       * @param {RollResults} results The results to run the modifier against
       * @param {StandardDice|RollGroup} _context The object that the modifier is attached to
       *
       * @returns {RollResults} The modified results
       */

    }, {
      key: "run",
      value: function run(results, _context) {
        var _this2 = this;

        var rolls;

        if (results instanceof ResultGroup) {
          rolls = results.results;
        } else {
          rolls = results.rolls;
        } // loop through each roll and see if it matches the target


        rolls.forEach(function (roll) {
          // add the modifier flag
          if (_this2.isSuccess(roll.value)) {
            roll.modifiers.add('target-success');
          } else if (_this2.isFailure(roll.value)) {
            roll.modifiers.add('target-failure');
          } // set the value to the success state value
          // eslint-disable-next-line no-param-reassign


          roll.calculationValue = _this2.getStateValue(roll.value);
        });
        return results;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  notation: string,
       *  name: string,
       *  type: string,
       *  comparePoint: (ComparePoint|undefined),
       *  failureComparePoint: (ComparePoint|null),
       *  successComparePoint: ComparePoint
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var failureComparePoint = this.failureComparePoint,
            successComparePoint = this.successComparePoint; // get the inherited object, but remove the comparePoint property

        var result = _get(_getPrototypeOf(TargetModifier.prototype), "toJSON", this).call(this);

        delete result.comparePoint;
        return Object.assign(result, {
          failureComparePoint: failureComparePoint,
          successComparePoint: successComparePoint
        });
      }
    }]);

    return TargetModifier;
  }(ComparisonModifier);

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ComparisonModifier: ComparisonModifier,
    CriticalFailureModifier: CriticalFailureModifier,
    CriticalSuccessModifier: CriticalSuccessModifier,
    DropModifier: DropModifier,
    ExplodeModifier: ExplodeModifier,
    KeepModifier: KeepModifier,
    MaxModifier: MaxModifier,
    MinModifier: MinModifier,
    Modifier: Modifier,
    ReRollModifier: ReRollModifier,
    SortingModifier: SortingModifier,
    TargetModifier: TargetModifier
  });

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ResultGroup: ResultGroup,
    RollResult: RollResult,
    RollResults: RollResults
  });

  /**
   * Check if the value is a valid base64 encoded string.
   *
   * @param {string} val
   *
   * @returns {boolean} `true` if it is valid base64 encoded, `false` otherwise
   */
  var isBase64 = function isBase64(val) {
    try {
      return !!(val && btoa(atob(val)) === val);
    } catch (e) {
      return false;
    }
  };
  /**
   * Check if the value is a valid JSON encoded string.
   *
   * @param {string} val
   *
   * @returns {boolean} `true` if the value is valid JSON, `false` otherwise
   */


  var isJson = function isJson(val) {
    try {
      var parsed = val ? JSON.parse(val) : false;
      return !!(parsed && _typeof(parsed) === 'object');
    } catch (e) {
      return false;
    }
  };

  var modifiersSymbol = Symbol('modifiers');
  var expressionsSymbol$1 = Symbol('expressions');
  /**
   * A `RollGroup` is a group of one or more "sub-rolls".
   *
   * A sub-roll is just simple roll notation (e.g. `4d6`, `2d10*3`, `5/10d20`)
   *
   * @example <caption>`{4d6+4, 2d%/5}k1`</caption>
   * const expressions = [
   *   [
   *     new StandardDice(6, 4),
   *     '+',
   *     4,
   *   ],
   *   [
   *     new PercentileDice(2),
   *     '/',
   *     5,
   *   ],
   * ];
   *
   * const modifiers = [
   *   new KeepModifier(),
   * ];
   *
   * const group = new RollGroup(expressions, modifiers);
   *
   * @since 4.5.0
   */

  var RollGroup = /*#__PURE__*/function () {
    /**
     * Create a `RollGroup` instance.
     *
     * @param {Array.<Array.<StandardDice|string|number>>} [expressions=[]] List of sub-rolls
     * @param {Map<string, Modifier>|Modifier[]|{}|null} [modifiers=[]] The modifiers that affect the
     * group
     */
    function RollGroup() {
      var expressions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      _classCallCheck(this, RollGroup);

      this.expressions = expressions;
      this.modifiers = modifiers;
    }
    /**
     * The sub-roll expressions in the group.
     *
     * @returns {Array.<Array.<StandardDice|string|number>>}
     */


    _createClass(RollGroup, [{
      key: "expressions",
      get: function get() {
        return _toConsumableArray(this[expressionsSymbol$1] || []);
      }
      /**
       * Set the sub-roll expressions in the group.
       *
       * @param {Array.<Array.<StandardDice|string|number>>} expressions
       *
       * @throws {TypeError} Expressions must be an array of arrays
       * @throws {TypeError} Sub expressions cannot be empty
       * @throws {TypeError} Sub expression items must be Dice, numbers, or strings
       */
      ,
      set: function set(expressions) {
        var _this = this;

        if (!expressions) {
          throw new RequiredArgumentError('expressions');
        }

        if (!Array.isArray(expressions)) {
          throw new TypeError("expressions must be an array: ".concat(expressions));
        } // loop through each expression and add it to the list


        this[expressionsSymbol$1] = [];
        expressions.forEach(function (expression) {
          if (!expression || !Array.isArray(expression)) {
            throw new TypeError("Expressions must be an array of arrays: ".concat(expressions));
          }

          if (expression.length === 0) {
            throw new TypeError("Sub expressions cannot be empty: ".concat(expressions));
          }

          if (!expression.every(function (value) {
            return value instanceof StandardDice || typeof value === 'string' || typeof value === 'number';
          })) {
            throw new TypeError('Sub expression items must be Dice, numbers, or strings');
          }

          _this[expressionsSymbol$1].push(expression);
        });
      }
      /**
       * The modifiers that affect the object.
       *
       * @returns {Map<string, Modifier>|null}
       */

    }, {
      key: "modifiers",
      get: function get() {
        if (this[modifiersSymbol]) {
          // ensure modifiers are ordered correctly
          return new Map(_toConsumableArray(this[modifiersSymbol]).sort(function (a, b) {
            return a[1].order - b[1].order;
          }));
        }

        return null;
      }
      /**
       * Set the modifiers that affect this group.
       *
       * @param {Map<string, Modifier>|Modifier[]|{}|null} value
       *
       * @throws {TypeError} Modifiers should be a Map, array of Modifiers, or an Object
       */
      ,
      set: function set(value) {
        var modifiers;

        if (value instanceof Map) {
          modifiers = value;
        } else if (Array.isArray(value)) {
          // loop through and get the modifier name of each item and use it as the map key
          modifiers = new Map(value.map(function (modifier) {
            return [modifier.name, modifier];
          }));
        } else if (_typeof(value) === 'object') {
          modifiers = new Map(Object.entries(value));
        } else {
          throw new TypeError('modifiers should be a Map, array, or an Object containing Modifiers');
        }

        if (modifiers.size && _toConsumableArray(modifiers.entries()).some(function (entry) {
          return !(entry[1] instanceof Modifier);
        })) {
          throw new TypeError('modifiers must only contain Modifier instances');
        }

        this[modifiersSymbol] = modifiers;
      }
      /**
       * The group notation. e.g. `{4d6, 2d10+3}k1`.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        var notation = this.expressions.map(function (expression) {
          return expression.reduce(function (acc, e) {
            return acc + e;
          }, '');
        }).join(', ');
        notation = "{".concat(notation, "}");

        if (this.modifiers && this.modifiers.size) {
          notation += _toConsumableArray(this.modifiers.values()).reduce(function (acc, modifier) {
            return acc + modifier.notation;
          }, '');
        }

        return notation;
      }
      /**
       * Run the sub-roll expressions for the group.
       *
       * @example <caption>`{4d6+4/1d6, 2d10/3}k1`</caption>
       * ResultGroup {
       *   results: [
       *     // sub-roll 1 - 4d6+4/1d6
       *     ResultGroup {
       *       results: [
       *         RollResults {
       *           rolls: [
       *             RollResult {
       *               value: 2
       *             },
       *             RollResult {
       *               value: 5
       *             },
       *             RollResult {
       *               value: 4
       *             },
       *             RollResult {
       *               value: 1
       *             }
       *           ]
       *         },
       *         '+',
       *         4,
       *         '/',
       *         RollResults {
       *           rolls: [
       *             RollResult {
       *               value: 4
       *             }
       *           ]
       *         }
       *       ]
       *     },
       *     // sub-roll 2 - 2d10/3
       *     ResultGroup {
       *       results: [
       *         RollResults {
       *           rolls: [
       *             RollResults {
       *               4
       *             },
       *             RollResults {
       *               9
       *             }
       *           ]
       *         },
       *         '/',
       *         3
       *       ]
       *     }
       *   ]
       * }
       *
       * @returns {ResultGroup} The results of the sub-rolls
       */

    }, {
      key: "roll",
      value: function roll() {
        var _this2 = this;

        // loop through each sub-roll expression and roll it
        // adding the results to a single RollResults object
        var rollResults = new ResultGroup(this.expressions.map(function (subRoll) {
          var result = subRoll.map(function (expression) {
            if (expression instanceof StandardDice) {
              // roll the object and return the value
              return expression.roll();
            }

            return expression;
          });
          return new ResultGroup(result);
        })); // flag it as roll group results

        rollResults.isRollGroup = true; // loop through each modifier and carry out its actions

        (this.modifiers || []).forEach(function (modifier) {
          modifier.run(rollResults, _this2);
        });
        return rollResults;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  notation: string,
       *  modifiers: (Map<string, Modifier>|null),
       *  type: string,
       *  expressions: Array.<Array.<StandardDice|string|number>>
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var modifiers = this.modifiers,
            notation = this.notation,
            expressions = this.expressions;
        return {
          expressions: expressions,
          modifiers: modifiers,
          notation: notation,
          type: 'group'
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @see {@link RollGroup#notation}
       *
       * @returns {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.notation;
      }
    }]);

    return RollGroup;
  }();

  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }

    C.prototype = parent.prototype;
    child.prototype = new C();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function literal(expectation) {
        return "\"" + literalEscape(expectation.text) + "\"";
      },
      class: function _class(expectation) {
        var escapedParts = expectation.parts.map(function (part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
      },
      any: function any() {
        return "any character";
      },
      end: function end() {
        return "end of input";
      },
      other: function other(expectation) {
        return expectation.description;
      }
    };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return "\\x" + hex(ch);
      });
    }

    function classEscape(s) {
      return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return "\\x" + hex(ch);
      });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = expected.map(describeExpectation);
      var i, j;
      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }

        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$startRuleFunctions = {
      Main: peg$parseMain
    };
    var peg$startRuleFunction = peg$parseMain;
    var peg$c0 = "{";
    var peg$c1 = peg$literalExpectation("{", false);
    var peg$c2 = ",";
    var peg$c3 = peg$literalExpectation(",", false);
    var peg$c4 = "}";
    var peg$c5 = peg$literalExpectation("}", false);

    var peg$c6 = function peg$c6(expr, exprs, modifiers) {
      return new RollGroup([expr].concat(_toConsumableArray(exprs.map(function (v) {
        return v[3];
      }))), Object.assign.apply(Object, [{}].concat(_toConsumableArray(modifiers.map(function (item) {
        return _defineProperty({}, item.name, item);
      })))));
    };

    var peg$c7 = function peg$c7(die, modifiers) {
      die.modifiers = Object.assign.apply(Object, [{}].concat(_toConsumableArray(modifiers.map(function (item) {
        return _defineProperty({}, item.name, item);
      }))));
      return die;
    };

    var peg$c8 = "d";
    var peg$c9 = peg$literalExpectation("d", false);

    var peg$c10 = function peg$c10(qty, sides) {
      return new StandardDice(sides, qty || 1);
    };

    var peg$c11 = "d%";
    var peg$c12 = peg$literalExpectation("d%", false);

    var peg$c13 = function peg$c13(qty) {
      return new PercentileDice(qty || 1);
    };

    var peg$c14 = "dF";
    var peg$c15 = peg$literalExpectation("dF", false);
    var peg$c16 = ".";
    var peg$c17 = peg$literalExpectation(".", false);
    var peg$c18 = /^[12]/;
    var peg$c19 = peg$classExpectation(["1", "2"], false, false);

    var peg$c20 = function peg$c20(qty, sides) {
      return new FudgeDice(sides ? parseInt(sides[1], 10) : 2, qty || 1);
    };

    var peg$c21 = "!";
    var peg$c22 = peg$literalExpectation("!", false);
    var peg$c23 = "p";
    var peg$c24 = peg$literalExpectation("p", false);

    var peg$c25 = function peg$c25(compound, penetrate, comparePoint) {
      return new ExplodeModifier(comparePoint, !!compound, !!penetrate);
    };

    var peg$c26 = function peg$c26(successCP, failureCP) {
      return new TargetModifier(successCP, failureCP);
    };

    var peg$c27 = /^[lh]/;
    var peg$c28 = peg$classExpectation(["l", "h"], false, false);

    var peg$c29 = function peg$c29(end, qty) {
      return new DropModifier(end || 'l', qty);
    };

    var peg$c30 = "k";
    var peg$c31 = peg$literalExpectation("k", false);

    var peg$c32 = function peg$c32(end, qty) {
      return new KeepModifier(end || 'h', qty);
    };

    var peg$c33 = "max";
    var peg$c34 = peg$literalExpectation("max", false);

    var peg$c35 = function peg$c35(max) {
      return new MaxModifier(max);
    };

    var peg$c36 = "min";
    var peg$c37 = peg$literalExpectation("min", false);

    var peg$c38 = function peg$c38(min) {
      return new MinModifier(min);
    };

    var peg$c39 = "r";
    var peg$c40 = peg$literalExpectation("r", false);
    var peg$c41 = "o";
    var peg$c42 = peg$literalExpectation("o", false);

    var peg$c43 = function peg$c43(once, comparePoint) {
      return new ReRollModifier(!!once, comparePoint);
    };

    var peg$c44 = "cs";
    var peg$c45 = peg$literalExpectation("cs", false);

    var peg$c46 = function peg$c46(comparePoint) {
      return new CriticalSuccessModifier(comparePoint);
    };

    var peg$c47 = "cf";
    var peg$c48 = peg$literalExpectation("cf", false);

    var peg$c49 = function peg$c49(comparePoint) {
      return new CriticalFailureModifier(comparePoint);
    };

    var peg$c50 = "s";
    var peg$c51 = peg$literalExpectation("s", false);
    var peg$c52 = "a";
    var peg$c53 = peg$literalExpectation("a", false);

    var peg$c54 = function peg$c54(dir) {
      return new SortingModifier(dir || 'a');
    };

    var peg$c55 = "f";
    var peg$c56 = peg$literalExpectation("f", false);

    var peg$c57 = function peg$c57(comparePoint) {
      return comparePoint;
    };

    var peg$c58 = function peg$c58(operator, value) {
      return new ComparePoint(operator, value);
    };

    var peg$c59 = "!=";
    var peg$c60 = peg$literalExpectation("!=", false);
    var peg$c61 = "<=";
    var peg$c62 = peg$literalExpectation("<=", false);
    var peg$c63 = ">=";
    var peg$c64 = peg$literalExpectation(">=", false);
    var peg$c65 = "=";
    var peg$c66 = peg$literalExpectation("=", false);
    var peg$c67 = ">";
    var peg$c68 = peg$literalExpectation(">", false);
    var peg$c69 = "<";
    var peg$c70 = peg$literalExpectation("<", false);
    var peg$c71 = "(";
    var peg$c72 = peg$literalExpectation("(", false);
    var peg$c73 = ")";
    var peg$c74 = peg$literalExpectation(")", false);

    var peg$c75 = function peg$c75(l, expr, r) {
      return evaluate(text());
    };

    var peg$c76 = function peg$c76(head, tail) {
      head = Array.isArray(head) ? head : [head];
      return [].concat(_toConsumableArray(head), _toConsumableArray(tail.map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 4),
            value = _ref4[1],
            factor = _ref4[3];

        return [value, factor];
      }).flat(2)));
    };

    var peg$c77 = function peg$c77(l, expr, r) {
      return [l].concat(_toConsumableArray(expr), [r]);
    };

    var peg$c78 = "abs";
    var peg$c79 = peg$literalExpectation("abs", false);
    var peg$c80 = "ceil";
    var peg$c81 = peg$literalExpectation("ceil", false);
    var peg$c82 = "cos";
    var peg$c83 = peg$literalExpectation("cos", false);
    var peg$c84 = "exp";
    var peg$c85 = peg$literalExpectation("exp", false);
    var peg$c86 = "floor";
    var peg$c87 = peg$literalExpectation("floor", false);
    var peg$c88 = "log";
    var peg$c89 = peg$literalExpectation("log", false);
    var peg$c90 = "round";
    var peg$c91 = peg$literalExpectation("round", false);
    var peg$c92 = "sign";
    var peg$c93 = peg$literalExpectation("sign", false);
    var peg$c94 = "sin";
    var peg$c95 = peg$literalExpectation("sin", false);
    var peg$c96 = "sqrt";
    var peg$c97 = peg$literalExpectation("sqrt", false);
    var peg$c98 = "tan";
    var peg$c99 = peg$literalExpectation("tan", false);

    var peg$c100 = function peg$c100(func, expr) {
      return ["".concat(func, "(")].concat(_toConsumableArray(expr), [')']);
    };

    var peg$c101 = "pow";
    var peg$c102 = peg$literalExpectation("pow", false);

    var peg$c103 = function peg$c103(func, expr1, expr2) {
      return ["".concat(func, "(")].concat(_toConsumableArray(expr1), [','], _toConsumableArray(expr2), [')']);
    };

    var peg$c104 = "-";
    var peg$c105 = peg$literalExpectation("-", false);
    var peg$c106 = /^[.]/;
    var peg$c107 = peg$classExpectation(["."], false, false);

    var peg$c108 = function peg$c108() {
      return parseFloat(text());
    };

    var peg$c109 = /^[1-9]/;
    var peg$c110 = peg$classExpectation([["1", "9"]], false, false);
    var peg$c111 = /^[0-9]/;
    var peg$c112 = peg$classExpectation([["0", "9"]], false, false);

    var peg$c113 = function peg$c113() {
      return parseInt(text(), 10);
    };

    var peg$c114 = "**";
    var peg$c115 = peg$literalExpectation("**", false);

    var peg$c116 = function peg$c116() {
      return "^";
    };

    var peg$c117 = "*";
    var peg$c118 = peg$literalExpectation("*", false);
    var peg$c119 = "^";
    var peg$c120 = peg$literalExpectation("^", false);
    var peg$c121 = "%";
    var peg$c122 = peg$literalExpectation("%", false);
    var peg$c123 = "/";
    var peg$c124 = peg$literalExpectation("/", false);
    var peg$c125 = "+";
    var peg$c126 = peg$literalExpectation("+", false);
    var peg$c127 = peg$otherExpectation("whitespace");
    var peg$c128 = /^[ \t\n\r]/;
    var peg$c129 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false);
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [{
      line: 1,
      column: 1
    }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return {
        type: "literal",
        text: text,
        ignoreCase: ignoreCase
      };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return {
        type: "class",
        parts: parts,
        inverted: inverted,
        ignoreCase: ignoreCase
      };
    }

    function peg$endExpectation() {
      return {
        type: "end"
      };
    }

    function peg$otherExpectation(description) {
      return {
        type: "other",
        description: description
      };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;

      if (details) {
        return details;
      } else {
        p = pos - 1;

        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }

    function peg$parseMain() {
      var s0;
      s0 = peg$parseExpression();
      return s0;
    }

    function peg$parseRollGroup() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c0;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c1);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();

        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpression();

          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parse_();

            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c2;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c3);
                }
              }

              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();

                if (s8 !== peg$FAILED) {
                  s9 = peg$parseExpression();

                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }

            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parse_();

              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c2;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c3);
                  }
                }

                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();

                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseExpression();

                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();

              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c4;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c5);
                  }
                }

                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseModifier();

                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseModifier();
                  }

                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s3, s4, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDice() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseStandardDie();

      if (s1 === peg$FAILED) {
        s1 = peg$parsePercentileDie();

        if (s1 === peg$FAILED) {
          s1 = peg$parseFudgeDie();
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseModifier();

        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseModifier();
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseStandardDie() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseIntegerOrExpression();

      if (s1 === peg$FAILED) {
        s1 = null;
      }

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 100) {
          s2 = peg$c8;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parseIntegerOrExpression();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c10(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePercentileDie() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parseIntegerOrExpression();

      if (s1 === peg$FAILED) {
        s1 = null;
      }

      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c11) {
          s2 = peg$c11;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c13(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFudgeDie() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parseIntegerOrExpression();

      if (s1 === peg$FAILED) {
        s1 = null;
      }

      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c14) {
          s2 = peg$c14;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c16;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }

          if (s4 !== peg$FAILED) {
            if (peg$c18.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 === peg$FAILED) {
            s3 = null;
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseModifier() {
      var s0;
      s0 = peg$parseExplodeModifier();

      if (s0 === peg$FAILED) {
        s0 = peg$parseTargetModifier();

        if (s0 === peg$FAILED) {
          s0 = peg$parseDropModifier();

          if (s0 === peg$FAILED) {
            s0 = peg$parseKeepModifier();

            if (s0 === peg$FAILED) {
              s0 = peg$parseReRollModifier();

              if (s0 === peg$FAILED) {
                s0 = peg$parseCriticalSuccessModifier();

                if (s0 === peg$FAILED) {
                  s0 = peg$parseCriticalFailureModifier();

                  if (s0 === peg$FAILED) {
                    s0 = peg$parseSortingModifier();

                    if (s0 === peg$FAILED) {
                      s0 = peg$parseMaxModifier();

                      if (s0 === peg$FAILED) {
                        s0 = peg$parseMinModifier();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseExplodeModifier() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c21;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c22);
        }
      }

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 33) {
          s2 = peg$c21;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }

        if (s2 === peg$FAILED) {
          s2 = null;
        }

        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 112) {
            s3 = peg$c23;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }

          if (s3 === peg$FAILED) {
            s3 = null;
          }

          if (s3 !== peg$FAILED) {
            s4 = peg$parseComparePoint();

            if (s4 === peg$FAILED) {
              s4 = null;
            }

            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c25(s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTargetModifier() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parseComparePoint();

      if (s1 !== peg$FAILED) {
        s2 = peg$parseFailComparePoint();

        if (s2 === peg$FAILED) {
          s2 = null;
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseDropModifier() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 100) {
        s1 = peg$c8;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c9);
        }
      }

      if (s1 !== peg$FAILED) {
        if (peg$c27.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        if (s2 === peg$FAILED) {
          s2 = null;
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parseIntegerNumber();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c29(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseKeepModifier() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 107) {
        s1 = peg$c30;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c31);
        }
      }

      if (s1 !== peg$FAILED) {
        if (peg$c27.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }

        if (s2 === peg$FAILED) {
          s2 = null;
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parseIntegerNumber();

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c32(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMaxModifier() {
      var s0, s1, s2;
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 3) === peg$c33) {
        s1 = peg$c33;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c34);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseFloatNumber();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMinModifier() {
      var s0, s1, s2;
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 3) === peg$c36) {
        s1 = peg$c36;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c37);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseFloatNumber();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c38(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseReRollModifier() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 114) {
        s1 = peg$c39;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c40);
        }
      }

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 111) {
          s2 = peg$c41;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }

        if (s2 === peg$FAILED) {
          s2 = null;
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parseComparePoint();

          if (s3 === peg$FAILED) {
            s3 = null;
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c43(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCriticalSuccessModifier() {
      var s0, s1, s2;
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 2) === peg$c44) {
        s1 = peg$c44;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c45);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparePoint();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCriticalFailureModifier() {
      var s0, s1, s2;
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 2) === peg$c47) {
        s1 = peg$c47;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c48);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparePoint();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseSortingModifier() {
      var s0, s1, s2;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 115) {
        s1 = peg$c50;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c51);
        }
      }

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 97) {
          s2 = peg$c52;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c53);
          }
        }

        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 100) {
            s2 = peg$c8;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c9);
            }
          }
        }

        if (s2 === peg$FAILED) {
          s2 = null;
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c54(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFailComparePoint() {
      var s0, s1, s2;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 102) {
        s1 = peg$c55;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c56);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseComparePoint();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c57(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseComparePoint() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parseCompareOperator();

      if (s1 !== peg$FAILED) {
        s2 = peg$parseFloatNumber();

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c58(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCompareOperator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c59) {
        s0 = peg$c59;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c60);
        }
      }

      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c61) {
          s0 = peg$c61;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c62);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c63) {
            s0 = peg$c63;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c64);
            }
          }

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s0 = peg$c65;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c66);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s0 = peg$c67;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c68);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 60) {
                  s0 = peg$c69;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c70);
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseIntegerOrExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
      s0 = peg$parseIntegerNumber();

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c71;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseFloatNumber();

            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              s7 = peg$parse_();

              if (s7 !== peg$FAILED) {
                s8 = peg$parseOperator();

                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();

                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseFloatNumber();

                    if (s10 !== peg$FAILED) {
                      s7 = [s7, s8, s9, s10];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }

              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$parse_();

                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseOperator();

                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();

                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseFloatNumber();

                        if (s10 !== peg$FAILED) {
                          s7 = [s7, s8, s9, s10];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
              } else {
                s5 = peg$FAILED;
              }

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c73;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c74);
                  }
                }

                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c75();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      s1 = peg$parseFactor();

      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();

        if (s4 !== peg$FAILED) {
          s5 = peg$parseOperator();

          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();

            if (s6 !== peg$FAILED) {
              s7 = peg$parseFactor();

              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }

        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();

          if (s4 !== peg$FAILED) {
            s5 = peg$parseOperator();

            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();

              if (s6 !== peg$FAILED) {
                s7 = peg$parseFactor();

                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c76(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFactor() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$parseMathFunction();

      if (s0 === peg$FAILED) {
        s0 = peg$parseDice();

        if (s0 === peg$FAILED) {
          s0 = peg$parseFloatNumber();

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c71;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c72);
              }
            }

            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();

              if (s2 !== peg$FAILED) {
                s3 = peg$parseExpression();

                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();

                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s5 = peg$c73;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c74);
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c77(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$parseRollGroup();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseMathFunction() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 3) === peg$c78) {
        s1 = peg$c78;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c79);
        }
      }

      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c80) {
          s1 = peg$c80;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c81);
          }
        }

        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c82) {
            s1 = peg$c82;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c83);
            }
          }

          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c84) {
              s1 = peg$c84;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c85);
              }
            }

            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c86) {
                s1 = peg$c86;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c87);
                }
              }

              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c88) {
                  s1 = peg$c88;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c89);
                  }
                }

                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c90) {
                    s1 = peg$c90;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c91);
                    }
                  }

                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c92) {
                      s1 = peg$c92;
                      peg$currPos += 4;
                    } else {
                      s1 = peg$FAILED;

                      if (peg$silentFails === 0) {
                        peg$fail(peg$c93);
                      }
                    }

                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 3) === peg$c94) {
                        s1 = peg$c94;
                        peg$currPos += 3;
                      } else {
                        s1 = peg$FAILED;

                        if (peg$silentFails === 0) {
                          peg$fail(peg$c95);
                        }
                      }

                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c96) {
                          s1 = peg$c96;
                          peg$currPos += 4;
                        } else {
                          s1 = peg$FAILED;

                          if (peg$silentFails === 0) {
                            peg$fail(peg$c97);
                          }
                        }

                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 3) === peg$c98) {
                            s1 = peg$c98;
                            peg$currPos += 3;
                          } else {
                            s1 = peg$FAILED;

                            if (peg$silentFails === 0) {
                              peg$fail(peg$c99);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s2 = peg$c71;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }

        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();

          if (s3 !== peg$FAILED) {
            s4 = peg$parseExpression();

            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();

              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c73;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c74);
                  }
                }

                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s1, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      if (s0 === peg$FAILED) {
        s0 = peg$currPos;

        if (input.substr(peg$currPos, 3) === peg$c101) {
          s1 = peg$c101;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c102);
          }
        }

        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }

          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c36) {
              s1 = peg$c36;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c71;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();

            if (s3 !== peg$FAILED) {
              s4 = peg$parseExpression();

              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();

                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c2;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c3);
                    }
                  }

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseExpression();

                      if (s8 !== peg$FAILED) {
                        s9 = peg$parse_();

                        if (s9 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s10 = peg$c73;
                            peg$currPos++;
                          } else {
                            s10 = peg$FAILED;

                            if (peg$silentFails === 0) {
                              peg$fail(peg$c74);
                            }
                          }

                          if (s10 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c103(s1, s4, s8);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseFloatNumber() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;

      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c104;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c105);
        }
      }

      if (s1 === peg$FAILED) {
        s1 = null;
      }

      if (s1 !== peg$FAILED) {
        s2 = peg$parseNumber();

        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;

          if (peg$c106.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c107);
            }
          }

          if (s4 !== peg$FAILED) {
            s5 = peg$parseNumber();

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          if (s3 === peg$FAILED) {
            s3 = null;
          }

          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c108();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseIntegerNumber() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;

      if (peg$c109.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c110);
        }
      }

      if (s1 !== peg$FAILED) {
        s2 = [];

        if (peg$c111.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c112);
          }
        }

        while (s3 !== peg$FAILED) {
          s2.push(s3);

          if (peg$c111.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
        }

        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c113();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];

      if (peg$c111.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c112);
        }
      }

      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);

          if (peg$c111.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c113();
      }

      s0 = s1;
      return s0;
    }

    function peg$parseOperator() {
      var s0, s1;
      s0 = peg$currPos;

      if (input.substr(peg$currPos, 2) === peg$c114) {
        s1 = peg$c114;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c115);
        }
      }

      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c116();
      }

      s0 = s1;

      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s0 = peg$c117;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c118);
          }
        }

        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 94) {
            s0 = peg$c119;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }

          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 37) {
              s0 = peg$c121;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              if (peg$silentFails === 0) {
                peg$fail(peg$c122);
              }
            }

            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s0 = peg$c123;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;

                if (peg$silentFails === 0) {
                  peg$fail(peg$c124);
                }
              }

              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                  s0 = peg$c125;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;

                  if (peg$silentFails === 0) {
                    peg$fail(peg$c126);
                  }
                }

                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s0 = peg$c104;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;

                    if (peg$silentFails === 0) {
                      peg$fail(peg$c105);
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;
      peg$silentFails++;
      s0 = [];

      if (peg$c128.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c129);
        }
      }

      while (s1 !== peg$FAILED) {
        s0.push(s1);

        if (peg$c128.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          if (peg$silentFails === 0) {
            peg$fail(peg$c129);
          }
        }
      }

      peg$silentFails--;

      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;

        if (peg$silentFails === 0) {
          peg$fail(peg$c127);
        }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }

  /**
   * The `Parser` takes a notation string and parses it into objects.
   *
   * It is used internally by the DiceRoll object when rolling notation, but can be used by itself if
   * necessary.
   *
   * @see {@link https://greenimp.github.io/rpg-dice-roller/guide/notation/}
   * @see {@link https://en.m.wikipedia.org/wiki/Dice_notation}
   */

  var Parser = /*#__PURE__*/function () {
    function Parser() {
      _classCallCheck(this, Parser);
    }

    _createClass(Parser, null, [{
      key: "parse",
      value:
      /**
       * Parses the given dice notation and returns a list of dice and modifiers found
       *
       * @param {string} notation The notation to parse
       *
       * @returns {Array}
       *
       * @throws {RequiredArgumentError} Notation is required
       * @throws {SyntaxError} The notation syntax is invalid
       * @throws {TypeError} Notation must be a string
       */
      function parse(notation) {
        if (!notation) {
          throw new RequiredArgumentError('notation');
        }

        if (typeof notation !== 'string') {
          throw new TypeError('Notation must be a string');
        } // parse the notation


        return peg$parse(notation);
      }
    }]);

    return Parser;
  }();

  /**
   * Allowed formats for exporting dice data
   *
   * @readonly
   *
   * @type {Readonly<{BASE_64: number, JSON: number, OBJECT: number}>}
   *
   * @property {number} BASE_64
   * @property {number} JSON
   * @property {number} OBJECT
   */
  var exportFormats = Object.freeze({
    BASE_64: 1,
    JSON: 0,
    OBJECT: 2
  });

  /**
   * The notation
   *
   * @type {symbol}
   *
   * @private
   */

  var notationSymbol = Symbol('notation');
  /**
   * The maximum possible roll total
   *
   * @type {symbol}
   *
   * @private
   */

  var maxTotalSymbol = Symbol('maxTotal');
  /**
   * The minimum possible roll total
   *
   * @type {symbol}
   *
   * @private
   */

  var minTotalSymbol = Symbol('minTotal');
  /**
   * List of expressions to roll
   *
   * @type {symbol}
   *
   * @private
   */

  var expressionsSymbol = Symbol('expressions');
  /**
   * Method for rolling dice
   *
   * @type {symbol}
   *
   * @private
   */

  var rollMethodSymbol = Symbol('roll-method');
  /**
   * List of rolls
   *
   * @type {symbol}
   *
   * @private
   */

  var rollsSymbol = Symbol('rolls');
  /**
   * Set the rolls
   *
   * @private
   *
   * @type {symbol}
   */

  var setRollsSymbol = Symbol('set-rolls');
  /**
   * The roll total
   *
   * @type {symbol}
   *
   * @private
   */

  var totalSymbol = Symbol('total');
  /**
   * Calculate the total of all the results, fixed to a max of 2 digits after the decimal point.
   *
   * @private
   *
   * @param {ResultGroup} results
   *
   * @returns {Number} the results total
   */

  var calculateTotal = function calculateTotal(results) {
    return toFixed(results.calculationValue, 2);
  };
  /**
   * A `DiceRoll` handles rolling of a single dice notation and storing it's result.
   *
   * @see {@link DiceRoller} if you need to keep a history of rolls
   */


  var DiceRoll = /*#__PURE__*/function () {
    /* eslint-disable max-len */

    /**
     * Create a DiceRoll, parse the notation and roll the dice.
     *
     * If `notation` is an object, it must contain a `notation` property that defines the notation.
     * It can also have an optional array of `RollResults`, in the `rolls` property.
     *
     * @example <caption>String notation</caption>
     * const roll = new DiceRoll('4d6');
     *
     * @example <caption>Object</caption>
     * const roll = new DiceRoll({
     *   notation: '4d6',
     *   rolls: ..., // RollResults object or array of roll results
     * });
     *
     * @param {string|{notation: string, rolls: ResultGroup|Array.<ResultGroup|RollResults|string|number>}} notation The notation to roll
     * @param {string} notation.notation If `notation is an object; the notation to roll
     * @param {ResultGroup|Array.<ResultGroup|RollResults|string|number>} [notation.rolls] If
     * `notation` is an object; the rolls to import
     *
     * @throws {NotationError} notation is invalid
     * @throws {RequiredArgumentError} notation is required
     * @throws {TypeError} Rolls must be a valid result object, or an array
     */
    function DiceRoll(notation) {
      _classCallCheck(this, DiceRoll);

      if (!notation) {
        throw new RequiredArgumentError('notation');
      } // initialise the parsed dice array


      this[expressionsSymbol] = [];

      if (notation instanceof Object && !Array.isArray(notation)) {
        // validate object
        // @todo see if we can assert that the notation is valid
        if (!notation.notation) {
          // object doesn't contain a notation property
          throw new RequiredArgumentError('notation');
        } else if (typeof notation.notation !== 'string') {
          throw new NotationError(notation.notation);
        } else if (notation.rolls) {
          // we have rolls - store them
          this[setRollsSymbol](notation.rolls);
        } // store the notation


        this[notationSymbol] = notation.notation; // parse the notation

        this[expressionsSymbol] = Parser.parse(this.notation);

        if (!this.hasRolls()) {
          // no rolls - roll the dice
          this.roll();
        }
      } else if (typeof notation === 'string') {
        // @todo see if we can assert that the notation is valid
        // store the notation
        this[notationSymbol] = notation; // parse the notation

        this[expressionsSymbol] = Parser.parse(this.notation); // roll the dice

        this.roll();
      } else {
        throw new NotationError(notation);
      }
    }
    /* eslint-enable max-len */

    /**
     * The average possible total for the notation.
     *
     * @since 4.3.0
     *
     * @returns {number}
     */


    _createClass(DiceRoll, [{
      key: "averageTotal",
      get: function get() {
        return (this.maxTotal + this.minTotal) / 2;
      }
      /**
       * The maximum possible total for the notation.
       *
       * @since 4.3.0
       *
       * @returns {number}
       */

    }, {
      key: "maxTotal",
      get: function get() {
        if (!this.hasExpressions()) {
          return 0;
        } // only calculate the total if it has not already been done


        if (!this[maxTotalSymbol]) {
          // roll the dice, forcing values to their maximum
          var rolls = this[rollMethodSymbol](engines.max); // calculate the total

          this[maxTotalSymbol] = calculateTotal(rolls);
        } // return the total


        return this[maxTotalSymbol];
      }
      /**
       * The minimum possible total for the notation.
       *
       * @since 4.3.0
       *
       * @returns {number}
       */

    }, {
      key: "minTotal",
      get: function get() {
        if (!this.hasExpressions()) {
          return 0;
        } // only calculate the total if it has not already been done


        if (!this[minTotalSymbol]) {
          // roll the dice, forcing values to their minimum
          var rolls = this[rollMethodSymbol](engines.min); // calculate the total

          this[minTotalSymbol] = calculateTotal(rolls);
        } // return the total


        return this[minTotalSymbol];
      }
      /**
       * The dice notation.
       *
       * @returns {string}
       */

    }, {
      key: "notation",
      get: function get() {
        return this[notationSymbol];
      }
      /**
       * String representation of the rolls
       *
       * @example
       * 2d20+1d6: [20,2]+[2] = 24
       *
       * @returns {string}
       */

    }, {
      key: "output",
      get: function get() {
        var output = "".concat(this.notation, ": ");

        if (this.hasRolls()) {
          output += "".concat(this[rollsSymbol], " = ").concat(this.total);
        } else {
          output += 'No dice rolled';
        }

        return output;
      }
      /**
       * The dice rolled for the notation
       *
       * @returns {Array.<ResultGroup|RollResults|string|number>}
       */

    }, {
      key: "rolls",
      get: function get() {
        return this[rollsSymbol] ? this[rollsSymbol].results : [];
      }
      /**
       * The roll total
       *
       * @returns {number}
       */

    }, {
      key: "total",
      get: function get() {
        // only calculate the total if it has not already been done
        if (!this[totalSymbol] && this.hasRolls()) {
          this[totalSymbol] = calculateTotal(this[rollsSymbol]);
        } // return the total


        return this[totalSymbol] || 0;
      }
      /**
       * Export the object in the given format.
       * If no format is specified, JSON is returned.
       *
       * @see {@link DiceRoll#toJSON}
       *
       * @param {exportFormats} [format=exportFormats.JSON] The format to export the data as
       *
       * @returns {string|null} The exported data, in the specified format
       *
       * @throws {TypeError} Invalid export format
       */

    }, {
      key: "export",
      value: function _export() {
        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exportFormats.JSON;

        switch (format) {
          case exportFormats.BASE_64:
            // JSON encode then base64, else it exports the string representation of the roll output
            return btoa(this.export(exportFormats.JSON));

          case exportFormats.JSON:
            return JSON.stringify(this);

          case exportFormats.OBJECT:
            return JSON.parse(this.export(exportFormats.JSON));

          default:
            throw new TypeError("Invalid export format \"".concat(format, "\""));
        }
      }
      /**
       * Check whether the DiceRoll has expressions or not.
       *
       * @returns {boolean} `true` if the object has expressions, `false` otherwise
       */

    }, {
      key: "hasExpressions",
      value: function hasExpressions() {
        return this[expressionsSymbol] && this[expressionsSymbol].length > 0;
      }
      /**
       * Check whether the object has rolled dice or not
       *
       * @returns {boolean} `true` if the object has rolls, `false` otherwise
       */

    }, {
      key: "hasRolls",
      value: function hasRolls() {
        return this.hasExpressions() && this.rolls.length > 0;
      }
      /**
       * Roll the dice for the stored notation.
       *
       * This is called in the constructor, so you'll only need this if you want to re-roll the
       * notation. However, it's usually better to create a new `DiceRoll` instance instead.
       *
       * @returns {RollResults[]} The results of the rolls
       */

    }, {
      key: "roll",
      value: function roll() {
        // reset the cached total
        this[totalSymbol] = 0; // save the rolls to the log

        this[rollsSymbol] = this[rollMethodSymbol](); // return the rolls;

        return this.rolls;
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{
       *  output: string,
       *  total: number,
       *  minTotal: number,
       *  maxTotal: number,
       *  notation: string,
       *  rolls: RollResults[],
       *  type: string
       * }}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var averageTotal = this.averageTotal,
            maxTotal = this.maxTotal,
            minTotal = this.minTotal,
            notation = this.notation,
            output = this.output,
            rolls = this.rolls,
            total = this.total;
        return {
          averageTotal: averageTotal,
          maxTotal: maxTotal,
          minTotal: minTotal,
          notation: notation,
          output: output,
          rolls: rolls,
          total: total,
          type: 'dice-roll'
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @returns {string}
       *
       * @see {@link DiceRoll#output}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.output;
      }
      /**
       * Create a new `DiceRoll` instance with the given data.
       *
       * `data` can be an object of data, a JSON / base64 encoded string of such data.
       *
       * The object must contain a `notation` property that defines the notation and, optionally, an
       * array of RollResults, in the `rolls` property.
       *
       * @example <caption>Object</caption>
       * DiceRoll.import({
       *   notation: '4d6',
       *   rolls: ..., // ResultGroup object or array of roll results
       * });
       *
       * @example <caption>JSON</caption>
       * DiceRoll.import('{"notation":"4d6","rolls":[...]}');
       *
       * @example <caption>Base64</caption>
       * DiceRoll.import('eyJub3RhdGlvbiI6IjRkNiIsInJvbGxzIjpbXX0=');
       *
       * @param {{notation: string, rolls: RollResults[]}|string} data The data to import
       * @param {string} data.notation If `notation` is an object; the notation to import
       * @param {RollResults[]} [data.rolls] If `notation` is an object; the rolls to import
       *
       * @returns {DiceRoll} The new `DiceRoll` instance
       *
       * @throws {DataFormatError} data format is invalid
       */

    }, {
      key: rollMethodSymbol,
      value:
      /**
       * Roll the dice and return the result.
       *
       * If the engine is passed, it will be used for the number generation for **this roll only**.
       * The engine will be reset after use.
       *
       * @private
       *
       * @param {{next(): number}} [engine] The RNG engine to use for die rolls
       *
       * @returns {ResultGroup} The result of the rolls
       *
       * @throws {TypeError} engine must have function `next()`
       */
      function value(engine) {
        var oEngine;

        if (engine) {
          // use the selected engine
          oEngine = generator.engine;
          generator.engine = engine;
        } // roll the dice


        var results = new ResultGroup(this[expressionsSymbol].map(function (expression) {
          if (expression instanceof StandardDice || expression instanceof RollGroup) {
            // roll the object and return the value
            return expression.roll();
          }

          return expression;
        }) // filter out empty values (e.g. whitespace)
        .filter(function (value) {
          return !!value || value === 0;
        }));

        if (engine) {
          // reset the engine
          generator.engine = oEngine;
        }

        return results;
      }
      /* eslint-disable max-len */

      /**
       * Set the rolls.
       *
       * @private
       *
       * @param {ResultGroup|Array.<ResultGroup|RollResults|string|number|{}|Array.<RollResult|number>>} rolls
       *
       * @throws {TypeError} Rolls must be a valid result object, or an array
       */

    }, {
      key: setRollsSymbol,
      value: function value(rolls) {
        if (rolls instanceof ResultGroup) {
          this[rollsSymbol] = rolls;
        } else if (rolls instanceof RollResults) {
          this[rollsSymbol] = new ResultGroup([rolls]);
        } else if (Array.isArray(rolls)) {
          this[rollsSymbol] = new ResultGroup(rolls.map(function (roll) {
            if (roll instanceof ResultGroup || roll instanceof RollResults) {
              // already a RollResults object
              return roll;
            } // @todo should this be a ResultGroup, or a RollResults?


            if (Array.isArray(roll)) {
              // array of values
              return new RollResults(roll);
            }

            if (_typeof(roll) === 'object') {
              // a result group
              if (Array.isArray(roll.results)) {
                return new ResultGroup(roll.results, roll.modifiers || [], roll.isRollGroup || false, typeof roll.useInTotal === 'boolean' ? roll.useInTotal : true);
              } // roll results


              if (Array.isArray(roll.rolls)) {
                return new RollResults(roll.rolls);
              }
            }

            return roll;
          }));
        } else {
          throw new TypeError('Rolls must be a valid result object, or an array');
        }
      }
      /* eslint-enable max-len */

    }], [{
      key: "import",
      value: function _import(data) {
        if (!data) {
          throw new RequiredArgumentError('data');
        } else if (isJson(data)) {
          // data is JSON format - parse and import
          return DiceRoll.import(JSON.parse(data));
        } else if (isBase64(data)) {
          // data is base64 encoded - decode and import
          return DiceRoll.import(atob(data));
        } else if (_typeof(data) === 'object') {
          // if data is a `DiceRoll` return it, otherwise build it
          return new DiceRoll(data);
        } else {
          throw new DataFormatError(data);
        }
      }
    }]);

    return DiceRoll;
  }();

  /**
   * history of log rolls
   *
   * @type {symbol}
   *
   * @private
   */

  var logSymbol = Symbol('log');
  /**
   * A `DiceRoller` handles dice rolling functionality, keeps a history of rolls and can output logs
   * etc.
   *
   * @see {@link DiceRoll} if you don't need to keep a log history of rolls
   */

  var DiceRoller = /*#__PURE__*/function () {
    /**
     * Create a DiceRoller.
     *
     * The optional `data` property should be either an array of `DiceRoll` objects, or an object with
     * a `log` property that contains the `DiceRoll` objects.
     *
     * @param {{log: DiceRoll[]}|DiceRoll[]} [data] The data to import
     * @param {DiceRoll[]} [data.log] If `data` is an object, it must contain an array of `DiceRoll`s
     *
     * @throws {TypeError} if data is an object, it must have a `log[]` property
     */
    function DiceRoller(data) {
      _classCallCheck(this, DiceRoller);

      this[logSymbol] = [];

      if (data) {
        this.import(data);
      }
    }
    /**
     * The list of roll logs.
     *
     * @returns {DiceRoll[]}
     */


    _createClass(DiceRoller, [{
      key: "log",
      get: function get() {
        return this[logSymbol] || [];
      }
      /**
       * String representation of the rolls in the log
       *
       * @example
       * 2d20+1d6: [20,2]+[2] = 24; 1d8: [6] = 6
       *
       * @returns {string}
       */

    }, {
      key: "output",
      get: function get() {
        return this.log.join('; ');
      }
      /**
       * The sum of all the rolls in the log
       *
       * @see {@link DiceRoller#log}
       *
       * @returns {number}
       */

    }, {
      key: "total",
      get: function get() {
        return this.log.reduce(function (prev, current) {
          return prev + current.total;
        }, 0);
      }
      /**
       * Clear the roll history log.
       *
       * @see {@link DiceRoller#log}
       */

    }, {
      key: "clearLog",
      value: function clearLog() {
        this[logSymbol].length = 0;
      }
      /**
       * Export the object in the given format.
       * If no format is specified, JSON is returned.
       *
       * @see {@link DiceRoller#toJSON}
       *
       * @param {exportFormats} [format=exportFormats#JSON] The format to export the data as
       *
       * @returns {string|null} The exported data, in the specified format
       *
       * @throws {TypeError} Invalid export format
       */

    }, {
      key: "export",
      value: function _export() {
        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exportFormats.JSON;

        switch (format) {
          case exportFormats.BASE_64:
            // JSON encode, then base64
            return btoa(this.export(exportFormats.JSON));

          case exportFormats.JSON:
            return JSON.stringify(this);

          case exportFormats.OBJECT:
            return JSON.parse(this.export(exportFormats.JSON));

          default:
            throw new TypeError("Invalid export format \"".concat(format, "\""));
        }
      }
      /**
       * Add the data to the existing [roll log]{@link DiceRoller#log}.
       *
       * `data` can be an array of `DiceRoll` objects, an object with a `log` property that contains
       * `DiceRoll` objects, or a JSON / base64 encoded representation of either.
       *
       * @see {@link DiceRoller#log}
       *
       * @param {string|{log: DiceRoll[]}|DiceRoll[]} data The data to import
       * @param {DiceRoll[]} [data.log] If `data` is an object, it must contain an array of `DiceRoll`s
       *
       * @returns {DiceRoll[]} The roll log
       *
       * @throws {DataFormatError} data format invalid
       * @throws {RequiredArgumentError} data is required
       * @throws {TypeError} log must be an array
       */

    }, {
      key: "import",
      value: function _import(data) {
        var _this = this;

        if (!data) {
          throw new RequiredArgumentError('data');
        } else if (isJson(data)) {
          // data is JSON - parse and import
          return this.import(JSON.parse(data));
        } else if (isBase64(data)) {
          // data is base64 encoded - decode an import
          return this.import(atob(data));
        } else if (_typeof(data) === 'object') {
          var log = data.log || null;

          if (!data.log && Array.isArray(data) && data.length) {
            // if `log` is not defined, but data is an array, use it as the list of logs
            log = data;
          }

          if (log && Array.isArray(log)) {
            // loop through each log entry and import it
            log.forEach(function (roll) {
              _this[logSymbol].push(DiceRoll.import(roll));
            });
          } else if (log) {
            throw new TypeError('log must be an array');
          }

          return this.log;
        } else {
          throw new DataFormatError(data);
        }
      }
      /**
       * Roll the given dice notation(s) and return the corresponding `DiceRoll` objects.
       *
       * You can roll a single notation, or multiple at once.
       *
       * @example <caption>Single notation</caption>
       * diceRoller.roll('2d6');
       *
       * @example <caption>Multiple notations</caption>
       * roll('2d6', '4d10', 'd8+4d6');
       *
       * @param {...string} notations The notations to roll
       *
       * @returns {DiceRoll|DiceRoll[]} If a single notation is passed, a single `DiceRoll` is returned,
       * otherwise an array of `DiceRoll` objects is returned
       *
       * @throws {NotationError} notation is invalid
       * @throws {RequiredArgumentError} notation is required
       */

    }, {
      key: "roll",
      value: function roll() {
        var _this2 = this;

        for (var _len = arguments.length, notations = new Array(_len), _key = 0; _key < _len; _key++) {
          notations[_key] = arguments[_key];
        }

        var filteredNotations = notations.filter(Boolean);

        if (filteredNotations.length === 0) {
          throw new RequiredArgumentError('notations');
        }

        var rolls = filteredNotations.map(function (notation) {
          var diceRoll = new DiceRoll(notation); // add the roll log to our global log

          _this2[logSymbol].push(diceRoll); // return the current DiceRoll


          return diceRoll;
        });
        return rolls.length > 1 ? rolls : rolls[0];
      }
      /**
       * Return an object for JSON serialising.
       *
       * This is called automatically when JSON encoding the object.
       *
       * @returns {{output: string, total: number, log: DiceRoll[], type: string}}
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var log = this.log,
            output = this.output,
            total = this.total;
        return {
          log: log,
          output: output,
          total: total,
          type: 'dice-roller'
        };
      }
      /**
       * Return the String representation of the object.
       *
       * This is called automatically when casting the object to a string.
       *
       * @returns {string}
       *
       * @see {@link DiceRoller#output}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.output;
      }
      /**
       * Create a new `DiceRoller` instance with the given data.
       *
       * `data` can be an array of `DiceRoll` objects, an object with a `log` property that contains the
       * `DiceRoll` objects, or a JSON / base64 encoded representation of either.
       *
       * @see instance method {@link DiceRoller#import}
       *
       * @param {string|{log: DiceRoll[]}|DiceRoll[]} data The data to import
       * @param {DiceRoll[]} [data.log] If `data` is an object, it must contain an array of `DiceRoll`s
       *
       * @returns {DiceRoller} The new `DiceRoller` instance
       *
       * @throws {DataFormatError} data format invalid
       * @throws {RequiredArgumentError} data is required
       * @throws {TypeError} log must be an array
       */

    }], [{
      key: "import",
      value: function _import(data) {
        // create a new DiceRoller object
        var diceRoller = new DiceRoller(); // import the data

        diceRoller.import(data); // return the DiceRoller

        return diceRoller;
      }
    }]);

    return DiceRoller;
  }();

  exports.ComparePoint = ComparePoint;
  exports.Dice = index$2;
  exports.DiceRoll = DiceRoll;
  exports.DiceRoller = DiceRoller;
  exports.Exceptions = index$3;
  exports.Modifiers = index$1;
  exports.NumberGenerator = NumberGenerator$1;
  exports.Parser = Parser;
  exports.Results = index;
  exports.RollGroup = RollGroup;
  exports.exportFormats = exportFormats;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
